<section class='introduction'><h1>Using OpenAPI Generator with Hummingbird</h1></section><section class='details literature'><p>The OpenAPI Generator for Swift is a recent addition to the ecosystem that enables you to generate Swift code from OpenAPI specifications. This documentation-first approach allows you to define your API before starting a project, enabling both client and server code generation across multiple languages.</p><p>OpenAPI specifications can support a variety of content types, such as JSON, XML, Multipart, binary files and streams of data. When using <a href='https://github.com/apple/swift-openapi-generator' target='_blank' rel='external'>OpenAPI Generator</a>  to generate a client, you’ll get a spec-compliant client implementation at the push of a button.</p><p>Servers generated from OpenAPI specifications are also spec-compliant. The generator creates an protocol named <code>APIProtocol</code> . Conforming to this type, you’ll need to implement all the routes defined in your OpenAPI specification. This ensures that your server is always in sync with your API specification.</p><p>The OpenAPI generator ensures that data is handled efficiently and correctly. It also provides a clear and concise way to define your API, making it easy to understand and maintain. It integrates well with Hummingbird, requiring minimal setup to get started.</p><p>In this tutorial, we’ll show you how to use the OpenAPI Generator to create a Swift API with Hummingbird (<a href='../whats-new-in-hummingbird-2'>What’s new in Hummingbird 2?</a>). If you’re using Hummingbird with AWS Lambda, you can also use the OpenAPI generator for handling routes in your Lambda function.</p><h2 id='Prerequisites'><a href='#Prerequisites'>Prerequisites</a></h2><p>This tutorial has a <a href='https://github.com/swift-on-server/using-openapi-with-hummingbird-sample' target='_blank' rel='external'>sample project</a>, containing a starter and finished project. You can use this to verify your setup.</p><h2 id='OpenAPI%20Generation'><a href='#OpenAPI%20Generation'>OpenAPI Generation</a></h2><p>The <a href='https://swagger.io/specification/' target='_blank' rel='external nofollow noopener ugc'>OpenAPI Specification</a> is a standard for defining HTTP APIs. It allows you to define the endpoints, request and response bodies, and other relevant details of your API in a machine-readable format.</p><p>When adding the OpenAPI generator to your project, you’ll need to add the following dependencies to your <code>Package.swift</code> file:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span>.<span class='xv'>package</span>(<span class='xv'>url</span>: <span class='xs'>"https://github.com/apple/swift-openapi-generator.git"</span>, <span class='xv'>from</span>: <span class='xs'>"1.2.0"</span>),<span class='newline'>
</span>.<span class='xv'>package</span>(<span class='xv'>url</span>: <span class='xs'>"https://github.com/apple/swift-openapi-runtime.git"</span>, <span class='xv'>from</span>: <span class='xs'>"1.3.0"</span>),<span class='newline'>
</span>.<span class='xv'>package</span>(<span class='xv'>url</span>: <span class='xs'>"https://github.com/apple/swift-argument-parser.git"</span>, <span class='xv'>from</span>: <span class='xs'>"1.3.0"</span>),<span class='newline'>
</span>.<span class='xv'>package</span>(<span class='xv'>url</span>: <span class='xs'>"https://github.com/hummingbird-project/hummingbird.git"</span>, <span class='xv'>from</span>: <span class='xs'>"2.0.0-rc.1"</span>),<span class='newline'>
</span>.<span class='xv'>package</span>(<span class='xv'>url</span>: <span class='xs'>"https://github.com/swift-server/swift-openapi-hummingbird.git"</span>, <span class='xv'>from</span>: <span class='xs'>"2.0.0-beta.4"</span>),</code></pre><p><strong>Note:</strong> <code>swift-argument-parser</code> is not related to Hummingbird or OpenAPI.</p><p>When working with OpenAPI generator, it’s helpful to create a separate module (target) for your generated OpenAPI code. First of all, this allows you to import the generated code into a client implementation. But more importantly, it prevents the Swift compiler from getting confusing about the generated code “not existing” at times. When separating the OpenAPI module, it is compiled first, helping avoid these issues.</p><p>In order to complete the setup, add the following to your Package manifest:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span>.<span class='xv'>target</span>(<span class='newline'>
</span>    <span class='xv'>name</span>: <span class='xs'>"MyOpenAPI"</span>,<span class='newline'>
</span>    <span class='xv'>dependencies</span>: [<span class='newline'>
</span>        <span class='xc'>// 1</span><span class='newline'>
</span>        .<span class='xv'>product</span>(<span class='xv'>name</span>: <span class='xs'>"OpenAPIRuntime"</span>, <span class='xv'>package</span>: <span class='xs'>"swift-openapi-runtime"</span>),<span class='newline'>
</span>    ],<span class='newline'>
</span>    <span class='xc'>// 2</span><span class='newline'>
</span>    <span class='xv'>plugins</span>: [.<span class='xv'>plugin</span>(<span class='xv'>name</span>: <span class='xs'>"OpenAPIGenerator"</span>, <span class='xv'>package</span>: <span class='xs'>"swift-openapi-generator"</span>)]<span class='newline'>
</span>),<span class='newline'>
</span>.<span class='xv'>executableTarget</span>(<span class='newline'>
</span>    <span class='xv'>name</span>: <span class='xs'>"MyApp"</span>,<span class='newline'>
</span>    <span class='xv'>dependencies</span>: [<span class='newline'>
</span>        <span class='xc'>// 3</span><span class='newline'>
</span>        .<span class='xv'>target</span>(<span class='xv'>name</span>: <span class='xs'>"MyOpenAPI"</span>),<span class='newline'>
</span>        .<span class='xv'>product</span>(<span class='xv'>name</span>: <span class='xs'>"Hummingbird"</span>, <span class='xv'>package</span>: <span class='xs'>"hummingbird"</span>),<span class='newline'>
</span>        .<span class='xv'>product</span>(<span class='xv'>name</span>: <span class='xs'>"OpenAPIHummingbird"</span>, <span class='xv'>package</span>: <span class='xs'>"swift-openapi-hummingbird"</span>),<span class='newline'>
</span>        .<span class='xv'>product</span>(<span class='xv'>name</span>: <span class='xs'>"ArgumentParser"</span>, <span class='xv'>package</span>: <span class='xs'>"swift-argument-parser"</span>),<span class='newline'>
</span>    ]<span class='newline'>
</span>),</code></pre><ol><li><p>Add the <code>OpenAPIRuntime</code> dependency to your OpenAPI module, this allows the generated code to make use of the shared OpenAPI types.</p></li><li><p>Add the <code>OpenAPIGenerator</code> plugin to your OpenAPI module. The plugin will generate the Swift code from your OpenAPI specification.</p></li><li><p>Add the <code>MyOpenAPI</code> target as a dependency to your application target. By importing this module, you can use the generated code in your application.</p></li></ol><p>OpenAPI generator is setup with a Swift Package Manager (SPM) plugin. The generated code will <em>not</em> be added to your source code, or even be visible in file browser.</p><p>When building the <strong>Finished</strong> project, you can find the generated code in the <code>.build/plugins</code> directory:</p><pre class='snippet'><code><span class='newline'></span>.build/plugins/outputs/finished/MyOpenAPI/OpenAPIGenerator/GeneratedSources</code></pre><h2 id='Creating%20a%20specification'><a href='#Creating%20a%20specification'>Creating a specification</a></h2><p>The OpenAPI specification is a YAML file that describes your API. It contains all public information needed to communicate between your API and clients.</p><p>The specification is written in <code>Sources/MyOpenAPI/openapi.yaml</code>. Here’s an example of a simple OpenAPI specification.</p><pre class='snippet'><code class='language-yaml'><span class='newline'></span>openapi: 3.0.0<span class='newline'>
</span>info:<span class='newline'>
</span>  title: My API<span class='newline'>
</span>  version: 1.0.0<span class='newline'>

</span># The routes on your API<span class='newline'>
</span>paths:<span class='newline'>
</span>  /hello:<span class='newline'>
</span>    # GET /hello<span class='newline'>
</span>    get:<span class='newline'>
</span>      operationId: greet<span class='newline'>
</span>      responses:<span class='newline'>
</span>        '200': # When the request is successful<span class='newline'>
</span>          description: A hello message<span class='newline'>
</span>          content:<span class='newline'>
</span>            application/json:<span class='newline'>
</span>              schema: # The returned JSON object<span class='newline'>
</span>                type: object<span class='newline'>
</span>                properties:<span class='newline'>
</span>                  message:<span class='newline'>
</span>                    type: string<span class='newline'>
</span>                required:<span class='newline'>
</span>                  - message</code></pre><p>In order to generate Swift code from this specification, you’ll need to add <code>openapi-generator-config.yaml</code> in the same directory as your specification. This file contains the configuration for the OpenAPI generator.</p><pre class='snippet'><code class='language-yaml'><span class='newline'></span>generate:<span class='newline'>
</span>  - types<span class='newline'>
</span>  - server<span class='newline'>
</span>accessModifier: public</code></pre><p>This configuration file tells the OpenAPI generator to generate types and server code, and to use public access modifiers for all types it generates. This ensures that the generated code is accessible from your application’s module. You can alternatively use the <code>package</code> access modifier to make the generated code accessible from the entire package, but not any apps that depend on this package.</p><aside class='note'><h3>Note</h3><p>If you want to generate the code needed to run an HTTP client, you can add <code>client</code> to the <code>generate</code> list.</p></aside><p>Finally, you’ll need an empty <code>.swift</code> file in your <code>Sources/MyOpenAPI</code> directory. This file is necessary for SPM to recognize the directory as a Swift module.</p><h2 id='Implementing%20the%20server'><a href='#Implementing%20the%20server'>Implementing the server</a></h2><p>Now that you have your OpenAPI specification and configuration, you can generate the Swift code. This happens automatically during <code>swift build</code>. In order to use the generated code, you’ll need to import the <code>MyOpenAPI</code> module in your application. Let’s create a new Hummingbird server that responds to the <code>/hello</code> route.</p><p>First, create a new file called <code>Sources/MyApp/HelloAPI.swift</code> with the following content:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>import</span> <span class='xv'>MyOpenAPI</span><span class='newline'>

</span><span class='xk'>struct</span> <span class='xv'>HelloAPI</span>: <span class='xt'>APIProtocol</span> {<span class='newline'>
</span>    <span class='xc'>// 1</span><span class='newline'>
</span>}</code></pre><p>The <code>APIProtocol</code> conformance refers to the generated <code>APIProtocol</code> from the OpenAPI specification. This protocol contains all the routes and request/response types defined in your OpenAPI specification. By conforming to this protocol, and implementing the required methods, you can create a server that responds to the routes defined in your OpenAPI specification. This guarantees that your server is always in sync with your API specification.</p><p>The <strong>operationId</strong> is used for the operationId and the Input/Output namespace. When conforming to <code>APIProtocol</code>, you’ll need to implement all methods that are defined in your OpenAPI specification. This provides compile-time guarantees that you’ve implemented all the routes defined in your OpenAPI specification.</p><p>Next, you’ll need to implement the <code>greet</code> method. This method is called when a client sends a <code>GET</code> request to <code>/hello</code>. Add the following code:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>struct</span> <span class='xv'>HelloAPI</span>: <span class='xt'>APIProtocol</span> {<span class='newline'>
</span>    <span class='xk'>func</span> <span class='xv'>greet</span>(_ <span class='xv'>input</span>: <span class='xt'>Operations</span>.<span class='xt'>greet</span>.<span class='xt'>Input</span>) <span class='xk'>async</span> <span class='xk'>throws</span> -&gt; <span class='xt'>Operations</span>.<span class='xt'>greet</span>.<span class='xt'>Output</span> {<span class='newline'>
</span>        <span class='xc'>// 1.</span><span class='newline'>
</span>        <span class='xk'>return</span> .<span class='xv'>ok</span>(.<span class='xk'>init</span>(<span class='xv'>body</span>:<span class='newline'>
</span>            <span class='xc'>// 2.</span><span class='newline'>
</span>            .<span class='xv'>json</span>(.<span class='xk'>init</span>(<span class='newline'>
</span>                <span class='xc'>// 3</span><span class='newline'>
</span>                <span class='xv'>message</span>: <span class='xs'>"Hello, world!"</span><span class='newline'>
</span>            ))<span class='newline'>
</span>        ))<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><p>As you see, the <code>greet</code> function is a simple generated signature. The <code>Input</code> type is the request, and the <code>Output</code> type is the response.</p><p>Both <code>Input</code> and <code>Output</code> types are very noticably generated types in OpenAPI, and look very verbose. Let’s break down what’s being returned:</p><ol><li><p>Return an HTTP 200 (OK) response</p></li><li><p>The OK response has a JSON body</p></li><li><p>The JSON body contains a <code>message</code> property with the value “Hello, world!”</p></li></ol><p>Note that the JSON body is not directly set in the body. This is necessary, because OpenAPI generator supports multipart and other types of responses. When working with HTTP bodies in <code>Input</code>, you’ll find back the same design.</p><h3 id='Verbosity%20and%20OpenAPI'><a href='#Verbosity%20and%20OpenAPI'>Verbosity and OpenAPI</a></h3><p>The verbosity of the generated types can be perceived as a downside to OpenAPI generator. It lacks the ‘slimness’ of most Swift APIs. However, as you work with OpenAPI more you’ll find that the verbosity is one of its strenghts in practice. It makes it very clear what the API expects and returns, making it hard or even impossible to overlook important details.</p><p>OpenAPI is a documentation-first approach, with the generated code being a direct reflection of this documentation. This builds a level of reliability and trust to your APIs and client implementations that is hard to achieve otherwise.</p><h2 id='Hosting%20the%20HelloAPI'><a href='#Hosting%20the%20HelloAPI'>Hosting the HelloAPI</a></h2><p>Finally, you’ll need to create a Hummingbird server that uses the <code>HelloAPI</code> to respond to the <code>/hello</code> route. Create a new file called <code>Sources/MyApp/App.swift</code> with the following content:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>import</span> <span class='xv'>ArgumentParser</span><span class='newline'>
</span><span class='xk'>import</span> <span class='xv'>Hummingbird</span><span class='newline'>
</span><span class='xk'>import</span> <span class='xv'>OpenAPIHummingbird</span><span class='newline'>
</span><span class='xk'>import</span> <span class='xv'>OpenAPIRuntime</span><span class='newline'>

</span><span class='xa'>@main</span> <span class='xk'>struct</span> <span class='xv'>HummingbirdArguments</span>: <span class='xt'>AsyncParsableCommand</span> {<span class='newline'>
</span>    <span class='xa'>@Option</span>(<span class='xv'>name</span>: .<span class='xv'>shortAndLong</span>)<span class='newline'>
</span>    <span class='xk'>var</span> <span class='xv'>hostname</span>: <span class='xt'>String</span> = <span class='xs'>"127.0.0.1"</span><span class='newline'>

</span>    <span class='xa'>@Option</span>(<span class='xv'>name</span>: .<span class='xv'>shortAndLong</span>)<span class='newline'>
</span>    <span class='xk'>var</span> <span class='xv'>port</span>: <span class='xt'>Int</span> = <span class='xn'>8080</span><span class='newline'>

</span>    <span class='xk'>func</span> <span class='xv'>run</span>() <span class='xk'>async</span> <span class='xk'>throws</span> {<span class='newline'>
</span>        <span class='xc'>// 1</span><span class='newline'>
</span>        <span class='xk'>let</span> <span class='xv'>router</span> = <span class='xv'>Router</span>()<span class='newline'>
</span>        <span class='xv'>router</span>.<span class='xv'>middlewares</span>.<span class='xv'>add</span>(<span class='xv'>LogRequestsMiddleware</span>(.<span class='xv'>info</span>))<span class='newline'>

</span>        <span class='xc'>// 2</span><span class='newline'>
</span>        <span class='xk'>let</span> <span class='xv'>api</span> = <span class='xv'>HelloAPI</span>()<span class='newline'>

</span>        <span class='xc'>// 3</span><span class='newline'>
</span>        <span class='xk'>try</span> <span class='xv'>api</span>.<span class='xv'>registerHandlers</span>(<span class='xv'>on</span>: <span class='xv'>router</span>)<span class='newline'>
</span>        <span class='newline'>
</span>        <span class='xc'>// 4</span><span class='newline'>
</span>        <span class='xk'>let</span> <span class='xv'>app</span> = <span class='xv'>Application</span>(<span class='newline'>
</span>            <span class='xv'>router</span>: <span class='xv'>router</span>,<span class='newline'>
</span>            <span class='xv'>configuration</span>: .<span class='xk'>init</span>(<span class='xv'>address</span>: .<span class='xv'>hostname</span>(<span class='xv'>hostname</span>, <span class='xv'>port</span>: <span class='xv'>port</span>))<span class='newline'>
</span>        )<span class='newline'>

</span>        <span class='xc'>// 5</span><span class='newline'>
</span>        <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>app</span>.<span class='xv'>runService</span>()<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><p>This code registers the <code>HelloAPI</code> routes, defined in your <code>openapi.yaml</code></p><p>Let’s break down the above:</p><ol><li><p>Create a new <code>Router</code> and add a logging middleware to it, allowing you to see the requests in the console.</p></li><li><p>Create a new <code>HelloAPI</code> instance. This is also the point where you can inject dependencies into your API implementation.</p></li><li><p>Register the HelloAPI’s handlers on the router. This will make the <code>HelloAPI</code> respond to the <code>/hello</code> route.</p></li><li><p>Create a new <code>Application</code> with the router and a configuration that specifies the hostname and port.</p></li><li><p>Run the application. This will make your route available at <a target='_blank' href='https://localhost:8080/hello' rel='external nofollow noopener ugc'>https://localhost:8080/hello</a>.</p></li></ol><p>That’s all it takes to create a Hummingbird server that responds to the <code>/hello</code> route using the OpenAPI generator. There are many more features and options available in the OpenAPI generator, such as multipart or generating client code for use with a client transport such as <a href='https://github.com/swift-server/async-http-client' target='_blank' rel='external'>async-http-client</a> and URLSession. We hope this tutorial has given you a good starting point for using the OpenAPI generator with Hummingbird.</p></section><div style='display: none;' id='ss:tooltips'><a href='/hist/swift-on-server.site:main/site/whats-new-in-hummingbird-2'><p>Hummingbird is a lightweight, flexible HTTP server framework written in Swift. The work on the second major version started last year and the first alpha version was tagged on the 22th of January, 2024. There are quite a lot of significant changes and under the hood improvements. It seems like the new APIs are mostly settled down at this point, so this is a great opportunity to introduce HB2. Let’s dive in.</p></a></div>