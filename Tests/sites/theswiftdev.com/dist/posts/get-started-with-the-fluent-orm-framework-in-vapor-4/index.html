<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Get started with the Fluent ORM framework in Vapor 4 - </title>
    <meta name="description" content="Learn how to use the Fluent ORM framework. Migrations, schemas, relations powered by PostgreSQL, written in Swift.">
    
    <meta property="og:url" content="/posts/get-started-with-the-fluent-orm-framework-in-vapor-4/">
    <meta property="og:title" content="Get started with the Fluent ORM framework in Vapor 4 - ">
    <meta property="og:description" content="Learn how to use the Fluent ORM framework. Migrations, schemas, relations powered by PostgreSQL, written in Swift.">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Get started with the Fluent ORM framework in Vapor 4 - ">
    <meta name="twitter:description" content="Learn how to use the Fluent ORM framework. Migrations, schemas, relations powered by PostgreSQL, written in Swift.">
    
    <link rel="stylesheet" href="/css/global.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">

    <link rel="shortcut icon" href="/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-touch-icon-180x180.png">

</head>

<body>
    <header id="navigation">
        <a id="site-logo" href="">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
        </a>
    
        <nav id="primary-menu">
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/">Home</a>
                <a href="/blog/">Blog</a>
                <a href="/posts/pages/1/">Posts</a>
                <a href="/authors/">Authors</a>
                <a href="/tags/">Tags</a>
                <a href="/my-page/">My page</a>
            </div>
        </nav>
    
        <nav id="secondary-menu">
            <input type="checkbox" id="secondary-menu-button" name="menu-button" class="menu-button">
            <label for="secondary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="1"></circle>
                    <circle cx="12" cy="5" r="1"></circle>
                    <circle cx="12" cy="19" r="1"></circle>
                </svg>
            </label>
            <div class="menu-items right">
                <a href="#">My account</a>
                <a href="/">Logout</a>
            </div>
        </nav>
    </header>
        
    <main>

<article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2020-02-27 16:20:00">2020-02-27 16:20:00</time>
            <h1 class="title">Get started with the Fluent ORM framework in Vapor 4</h1>
            <p class="excerpt">Learn how to use the Fluent ORM framework. Migrations, schemas, relations powered by PostgreSQL, written in Swift.</p>
        </section>
        
    </header>

    <section id="contents" class="content-wrapper">
    
    <blockquote><p>NOTE: If you want to learn Fluent, but you don‚Äôt have a working PostgreSQL installation, you should check my <a href="https://theswiftdev.com/how-to-set-up-pgsql-for-fluent-4/" target="_blank">tutorial about how to install and use pgSQL</a> before you start reading this one.</p></blockquote><h2>Using the Fluent ORM framework</h2><p>The beauty of an <a href="https://en.wikipedia.org/wiki/Object-relational_mapping" target="_blank">ORM</a> framework is that it hides the complexity of the underlying database layer. <a href="https://docs.vapor.codes/4.0/fluent/config/" target="_blank">Fluent 4</a> comes with multiple database driver implementations, this means that you can easily replace the recommended PostgreSQL driver with <a href="https://sqlite.org/index.html" target="_blank">SQLite</a>, <a href="https://www.mysql.com/" target="_blank">MySQL</a> or <a href="https://www.mongodb.com/" target="_blank">MongoDB</a> if you want. <a href="https://mariadb.com/" target="_blank">MariaDB</a> is also supported through the MySQL driver.</p><p>If you are using the SQLite database driver you might have to install the corresponding package (<code>brew install sqlite</code>) if you run into the following error: ‚Äúmissing required module ‚ÄòCSQLite‚Äô‚Äù. üòä</p><p>In this tutorial we‚Äôll use PostgreSQL, since that‚Äôs the new default driver in Vapor 4. First you have to create a database, next we can start a new Vapor project & write some Swift code using Fluent. If you create a new project using the toolbox (<code>vapor new myProject</code>) you‚Äôll be asked which database driver to use. If you are creating a project from scratch you can alter the <code>Package.swift</code> file:</p><pre><code class="language-swift">// swift-tools-version:5.2
import PackageDescription

let package = Package(
    name: "pgtut",
    platforms: [
       .macOS(.v10_15)
    ],
    dependencies: [
        // üíß A server-side Swift web framework.
        .package(url: "https://github.com/vapor/vapor.git", from: "4.3.0"),
        .package(url: "https://github.com/vapor/fluent.git", from: "4.0.0-rc"),
        .package(url: "https://github.com/vapor/fluent-postgres-driver.git", from: "2.0.0-rc")
    ],
    targets: [
        .target(name: "App", dependencies: [
            .product(name: "Fluent", package: "fluent"),
            .product(name: "FluentPostgresDriver", package: "fluent-postgres-driver"),
            .product(name: "Vapor", package: "vapor")
        ]),
        .target(name: "Run", dependencies: ["App"]),
        .testTarget(name: "AppTests", dependencies: [
            .target(name: "App"),
            .product(name: "XCTVapor", package: "vapor"),
        ])
    ]
)
</code></pre><p>Open the <code>Package.swift</code> file in Xcode, wait until all the dependencies are loaded.</p><p>Let‚Äôs configure the psql database driver in the <code>configure.swift</code> file. We‚Äôre going to use a database URL string to provide the connection details, loaded from the local environment.</p><pre><code class="language-swift">import Vapor
import Fluent
import FluentPostgresDriver

extension Application {
    static let databaseUrl = URL(string: Environment.get("DB_URL")!)!
}

public func configure(_ app: Application) throws {
    
    try app.databases.use(.postgres(url: Application.databaseUrl), as: .psql)
    
    //...
}
</code></pre><p>Create a new <code>.env.development</code> file in the project directory with the following contents:</p><pre><code>DB_URL=postgres://myuser:mypass@localhost:5432/mydb
</code></pre><p>You can also <a href="https://docs.vapor.codes/4.0/fluent/config/" target="_blank">configure</a> the driver using other methods, but I personally prefer this approach, since it‚Äôs very easy and you can also put other specific environmental variables right next to the DB_URL.</p><blockquote><p>NOTE: You can also use the <code>.env</code> file in production mode to set your environmental variables.</p></blockquote><p>Run the application, but first make sure that the current working directory is set properly, read more about this in my previous tutorial about <a href="https://theswiftdev.com/how-to-create-your-first-website-using-vapor-4-and-leaf/" target="_blank">the leaf templating engine</a>.</p><p>Well done, you have a working project that connects to the pgSQL server using Fluent. üöÄ</p><h2>Model definition</h2><p>The <a href="https://docs.vapor.codes/4.0/fluent/overview/" target="_blank">official documentation</a> pretty much covers all the important concepts, so it‚Äôs definitely worth a read. In this section, I‚Äôm only going to focus on some of the ‚Äúmissing parts‚Äù.</p><p>The API template sample code comes with a <code>Todo</code> model which is pretty much a good starting point for us.</p><h3>Field keys</h3><p>Field keys are available from the <a href="https://github.com/vapor/fluent-kit/releases/tag/1.0.0-beta.5" target="_blank">5th major beta</a> version of Fluent 4. Long story short, you don‚Äôt have to repeat yourself anymore, but you can define a key for each and every database field. As a gratis you never have to do the same for id fields, since fluent has built-in support for identifiers.</p><pre><code class="language-swift">extension FieldKey {
    static var title: Self { "title" }
}

// model definition
@ID() var id: UUID?
@Field(key: .title) var title: String

// migration
.id()
.field(.title, .string, .required)
</code></pre><h3>Identifiers are now UUID types by default</h3><p>Using the new <code>@ID</code> property wrapper and the <code>.id()</code> migration function will automatically require your models to have a <code>UUID</code> value by default. This is a great change, because I don‚Äôt really like serial identifiers. If you want to go use integers as identifiers you can still do it. Also you can define <code>UUID</code> fields with the old-school syntax, but if you go so you can have some troubles with switching to the new MongoDB driver, so please don‚Äôt do it. ü•∫</p><pre><code class="language-swift">// custom int identifier (won't work with MongoDB driver)
@ID(custom: "todo_id")
var id: Int?

// custom id type & field name (you have to generate it)
@ID(custom: "todo_identifier", generatedBy: .user)
var id: String?

// old-school uuid field migration
.field("id", .uuid, .identifier(auto: false))
</code></pre><h3>How to store native database enums?</h3><p>If you want to store enums using Fluent you have two options now. The first one is that you simply save your enums as native values (int, string, etc.), if you do so you just need an enum with a new field of the given type, plus you have to conform the enum to the Codable protocol.</p><pre><code class="language-swift">// model definition
enum Status: String, Codable {
    case pending
    case completed
}

@Field(key: "status") var status: Status

// migration (you can use the .int or .string type)
.field("status", .string, .required)
</code></pre><p>The second option is to use the new <code>@Enum</code> field type and migrate everything using the enum builder. This method requires more setup, but I think it‚Äôs going to worth it on the long term.</p><pre><code class="language-swift">// model definition
extension FieldKey {
    static var status: Self { "status" }
}

enum Status: String, Codable, CaseIterable {
    static var name: FieldKey { .status }

    case pending
    case completed
}

@Enum(key: .status) var status: Status

// migration
struct CreateTodo: Migration {
    func prepare(on database: Database) -> EventLoopFuture<Void> {
        var enumBuilder = database.enum(Todo.Status.name.description)
        for option in Todo.Status.allCases {
            enumBuilder = enumBuilder.case(option.rawValue)
        }
        return enumBuilder.create()
        .flatMap { enumType in
            database.schema(Todo.schema)
                .id()
                .field(.title, .string, .required)
                .field(.status, enumType, .required)
                .create()
        }
    }

    func revert(on database: Database) -> EventLoopFuture<Void> {
        return database.schema(Todo.schema).delete().flatMap {
            database.enum(Todo.Status.name.description).delete()
        }
    }
}
</code></pre><p>The main advantage of this approach that Fluent can take advantage of the database driver‚Äôs built-in enum type support. Also if you want to store native enums you have to migrate the fields if you introduce a new case. You can read more about this in the <a href="https://github.com/vapor/fluent-kit/releases/tag/1.0.0-beta.5" target="_blank">beta release notes</a>. I can‚Äôt tell you which one is the best way, since this is a brand new feature, I have to run some tests. ‚úÖ</p><h3>Saving option sets in Fluent</h3><p>There is a great post written by <a href="https://x.com/BastianInuk/" target="_blank">Bastian Inuk</a> about <a href="https://www.inuk.blog/vapor-fluent-4-and-enums/" target="_blank">managing user roles using option sets</a> in Fluent. You should definitely take a look if you want to use an OptionSet as a Fluent property. Anyway, I‚Äôll show you how to create this type, so we‚Äôll be able to flag our todo items. üî¥üü£üü†üü°üü¢üîµ‚ö™Ô∏è</p><pre><code class="language-swift">// model definition
extension FieldKey {
    static var labels: Self { "labels" }
}

struct Labels: OptionSet, Codable {
    var rawValue: Int
    
    static let red = Labels(rawValue: 1 << 0)
    static let purple = Labels(rawValue: 1 << 1)
    static let orange = Labels(rawValue: 1 << 2)
    static let yellow = Labels(rawValue: 1 << 3)
    static let green = Labels(rawValue: 1 << 4)
    static let blue = Labels(rawValue: 1 << 5)
    static let gray = Labels(rawValue: 1 << 6)
    
    static let all: Labels = [.red, .purple, .orange, .yellow, .green, .blue, .gray]
}

@Field(key: .labels) var labels: Labels

// migration
.field(.labels, .int, .required)
</code></pre><blockquote><p>NOTE: There is a nice Option protocol <a href="https://nshipster.com/optionset/" target="_blank">OptionSet</a></p></blockquote><h3>Storing dates</h3><p>Fluent can also store dates and times and convert them back-and-forth using the built-in <code>Date</code> object from Foundation. You just have to choose between the <code>.date</code> or <code>.datetime</code> storage types. You should go with the first one if you don‚Äôt care about the hours, minutes or seconds. The second one is good if you simply want to save the day, month and year. üíæ</p><blockquote><p>WARN: You should always go with the exact same <code>TimeZone</code> when you save / fetch dates from the database. When you save a date object that is in UTC, next time if you want to filter those objects and you use a different time zone (e.g. PDT), you‚Äôll get back a bad set of results.</p></blockquote><p>Here is the final example of our <code>Todo</code> model including the migration script:</p><pre><code class="language-swift">// model definition
final class Todo: Model, Content {

    static let schema = "todos"
    
    enum Status: String, Codable {
        case pending
        case completed
    }

    struct Labels: OptionSet, Codable {
        var rawValue: Int
        
        static let red = Labels(rawValue: 1 << 0)
        static let purple = Labels(rawValue: 1 << 1)
        static let orange = Labels(rawValue: 1 << 2)
        static let yellow = Labels(rawValue: 1 << 3)
        static let green = Labels(rawValue: 1 << 4)
        static let blue = Labels(rawValue: 1 << 5)
        static let gray = Labels(rawValue: 1 << 6)
        
        static let all: Labels = [
            .red,
            .purple,
            .orange,
            .yellow,
            .green,
            .blue,
            .gray
        ]
    }

    @ID() var id: UUID?
    @Field(key: .title) var title: String
    @Field(key: .status) var status: Status
    @Field(key: .labels) var labels: Labels
    @Field(key: .due) var due: Date?

    init() { }

    init(id: UUID? = nil,
         title: String,
         status: Status = .pending,
         labels: Labels = [],
         due: Date? = nil)
    {
        self.id = id
        self.title = title
        self.status = status
        self.labels = labels
        self.due = due
    }
}

// migration
struct CreateTodo: Migration {
    func prepare(on database: Database) -> EventLoopFuture<Void> {
        return database.schema(Todo.schema)
            .id()
            .field(.title, .string, .required)
            .field(.status, .string, .required)
            .field(.labels, .int, .required)
            .field(.due, .datetime)
            .create()
    }

    func revert(on database: Database) -> EventLoopFuture<Void> {
        return database.schema(Todo.schema).delete()
    }
}
</code></pre><p>One more thing‚Ä¶</p><h3>Nested fields & compound fields</h3><p>Sometimes you might need to save additional structured data, but you don‚Äôt want to introduce a relation (e.g. attributes with different keys, values). This is when the <code>@NestedField</code> property wrapper comes extremely handy. I won‚Äôt include here an example, since I had no time to try this feature yet, but you can read more about it <a href="https://github.com/vapor/fluent-kit/releases/tag/1.0.0-beta.5" target="_blank">here</a> with a working sample code.</p><p>The difference between a <code>@CompoundField</code> and a <code>@NestedField</code> is that a compound field is stored as a flat top level field in the database, but the other will be stored as a nested object.</p><blockquote><p>NOTE: Sets are now compatible with the array database type, you can use them like this: <code>.field(.mySetField, .array(of: .string), .required)</code></p></blockquote><p>I think we pretty much covered everything that you‚Äôll need in order to create DB entities. We‚Äôll have a quick detour here before we get into relations. üöß</p><h2>Schemas & migrations</h2><p>The <code>Todo</code> object is more or less ready to use, but this is just one part of the whole story. We still need to create the actual database table that can store our objects in PostgreSQL. In order to create the DB schema based on our Swift code, we have to run the migration command.</p><p>Migration is the process of creating, updating or deleting one or more database tables. In other words, everything that alters the database schema is a migration. You should know that you can register multiple migration scripts and Vapor will run them always in the order they were added.</p><blockquote><p>NOTE: The name of your database table & the fields are declared in your model. The schema is the name of the table, and the property wrappers are containing the name of each field.</p></blockquote><p>Nowadays I prefer to use a semantic version suffix for all my migration objects, this is really handy because I don‚Äôt have to think too much about the naming conventions, migration_v1_0_0 is always the create operation, everything comes after this version is just an altering the schema.</p><p>You can implement a <code>var name: String { "custom-migration-name" }</code> property inside the migration struct / class, so you don‚Äôt have to put special characters into your object‚Äôs name</p><blockquote><p>WARN: You should be careful with relations! If you are trying to use a table with a field as a foreign key you have to make sure that the referenced object already exists, otherwise it‚Äôll fail.</p></blockquote><p>During the first migration Fluent will create an internal lookup table named <code>_fluent_migrations</code>. The migration system is using this table to detect which migrations were already performed and what needs to be done next time you run the migrate command.</p><p>In order to perform a migration you can launch the Run target with the migrate argument. If you pass the <code>--auto-migrate</code> flag you don‚Äôt have to confirm the migration process. Be careful. üò≥</p><pre><code class="language-sh">swift run Run migrate
</code></pre><p>You can revert the last batch of migrations by running the command with the ‚Äìrevert flag.</p><pre><code class="language-sh">swift run Run migrate --revert
</code></pre><p>Here is a quick example how to run multiple schema updates by using flatten function. This migration simply removes the existing title field, and creates new unique name field.</p><pre><code class="language-swift">extension FieldKey {
    static var name: Self { "name" }
}

struct UpdateTodo: Migration {

    func prepare(on database: Database) -> EventLoopFuture<Void> {
        database.eventLoop.flatten([
            database.schema(Todo.schema)
                .deleteField(.title)
                .update(),
            database.schema(Todo.schema)
                .field(.name, .string, .required)
                .unique(on: .name)
                .update(),
            // you can also create objects in migration scripts
            Todo(name: "Hello world").save(on: database),
        ])
    }
    
    func revert(on database: Database) -> EventLoopFuture<Void> {
        database.eventLoop.flatten([
            database.schema(Todo.schema)
                .deleteField(.name)
                .update(),
            database.schema(Todo.schema)
                .field(.title, .string, .required)
                .update(),
        ])
    }
}
</code></pre><p>Feel free to go ahead, migrate the <code>Todo</code> scheme so we can write some queries.</p><h2>Querying</h2><p>Again I have to refer to the <a href="https://docs.vapor.codes/4.0/fluent/overview/#querying" target="_blank">official 4.0 Fluent docs</a>. Please go ahead read the querying section carefully, and come back to this article. The <code>TodoController</code> also provides a basic Swift sample code. IMHO a controller is an interactor, nowadays I‚Äôm using VIPER on the backend side as well (article coming soon). Here are a few CRUD practices. üòÖ</p><h3>Creating multiple records at once</h3><p>This one is simple, please note that the <code>save</code> method in Fluent behaves like an upsert command. If your model exists, it‚Äôll <code>update</code> otherwise it calls the <code>create</code> function. Anyway you can always call create on a bunch of models to perform a batch insert.</p><pre><code class="language-swift">let todos = [
    Todo(title: "Publish new article tomorrow"),
    Todo(title: "Finish Fluent tutorial"),
    Todo(title: "Write more blog posts"),
]
todos.create(on: req.db)
</code></pre><h3>Batch delete records</h3><p>You can query all the required records using filters and call the .delete() method on them.</p><pre><code class="language-swift">Todo.query(on: req.db)
        .filter(\.$status == .completed)
        .delete()
</code></pre><h3>How to update or delete a single record?</h3><p>If you know the object identifier it‚Äôs pretty simple, the <code>Model</code> protocol has a find method for this purpose. Otherwise you can query the required object and request the first one.</p><blockquote><p>NOTE: Fluent is asynchronous by default, this means that you have to work a lot with Futures and Promises. You can read my <a href="https://theswiftdev.com/promises-in-swift-for-beginners/" target="_blank">tutorial for beginners about promises in Swift</a>.</p></blockquote><p>You can use the <code>.map</code> or <code>.flatMap</code> methods to perform the necessary actions & return a proper response. The <code>.unwrap</code> function is quite handy, since you don‚Äôt have to unwrap optionals by hand in the other blocks. Block based syntax = you have to deal with memory management. üí©</p><pre><code class="language-swift">// update an existing record (find by uuid)
_ = Todo.find(uuid, on: req.db)
.unwrap(or: Abort(.notFound))
.flatMap { todo -> EventLoopFuture<Void> in
    todo.title = ""
    return todo.save(on: req.db)
}

//delete an existing record (find first using filters)
_ = Todo.query(on: req.db)
    .filter(\.$title == "Hello world")
    .first()
    .unwrap(or: Abort(.notFound))
    .flatMap { $0.delete(on: req.db) }
</code></pre><p>That‚Äôs it about creating, requesting, updating and deleting entities.</p><h2>Relations</h2><p>Sometimes you want to store some additional information in a separate database. In our case for example we could make a dynamic tagging system for the todo items. These tags can be stored in a separate table and they can be connected to the todos by using a relation. A relation is nothing more than a foreign key somewhere in the other table or inside a pivot.</p><h3>One-to-one relations</h3><p>Fluent supports one-to-many <a href="https://docs.vapor.codes/4.0/fluent/overview/#relations" target="_blank">relations</a> out of the box. The documentation clearly explains everything about them, but I‚Äôd like to add a few notes, time to build a one-to-many relation.</p><p>If you want to model a one-to-one relation the foreign key should be unique for the related table. Let‚Äôs add a detail table to our todo items with a separately stored description field.</p><pre><code class="language-swift">extension FieldKey {
    static var todoId: Self { "todo_id" }
    static var description: Self { "description" }
}

final class Detail: Model, Content {

    static let schema = "details"

    @ID() var id: UUID?
    @Parent(key: .todoId) var todo: Todo
    @Field(key: .description) var description: String

    init() { }

    init(id: UUID? = nil, description: String, todoId: UUID) {
        self.id = id
        self.description = description
        self.$todo.id = todoId
    }
}
</code></pre><p>The model above has a parent relation to a <code>Todo</code> object through a <code>todo_id</code> field. In other words, we simply store the original todo identifier in this table. Later on we‚Äôll be able to query the associated descriptions by using this foreign key. Let me show you the migration:</p><pre><code class="language-swift">struct CreateTodo: Migration {
    
    func prepare(on database: Database) -> EventLoopFuture<Void> {
        database.eventLoop.flatten([
            database.schema(Todo.schema)
                .id()
                .field(.title, .string, .required)
                .field(.status, .string, .required)
                .field(.labels, .int, .required)
                .field(.due, .datetime)
                .create(),
            database.schema(Detail.schema)
                .id()
                .field(. todoId, .uuid, .required)
                .foreignKey(.todoId, references: Todo.schema, .id, onDelete: .cascade, onUpdate: .noAction)
                .field(.description, .string, .required)
                .unique(on: .todoId)
                .create(),
        ])
    }

    func revert(on database: Database) -> EventLoopFuture<Void> {
        database.eventLoop.flatten([
            database.schema(Detail.schema).delete(),
            database.schema(Todo.schema).delete(),
        ])
    }
}
</code></pre><p>The final step here is to extend the <code>Todo</code> model with the child reference.</p><pre><code class="language-swift">@Children(for: \.$todo) var details: [Detail]
</code></pre><p>Creating a relation only takes a few lines of Swift code</p><pre><code class="language-swift">let todo = Todo(title: "Finish the Fluent article already")
todo.create(on: app.db)
.flatMap { _ in
    Detail(description: "write some cool things about Fluent relations",
           todoId: todo.id!).create(on: req.db)
}
</code></pre><p>Now if you try to add multiple details to the same todo object the you won‚Äôt be able to perform that DB query, since the <code>todo_id</code> has a unique constraint, so you must be extremely carful with these kind of operations. Apart from this limitation (that comes alongside with a one-to-one relation) you use both objects as usual (find by id, eager load the details from the todo object, etc.). ü§ì</p><h3>One-to-many relations</h3><p>A one-to-many relation is just like a one-to-one, except that you can associate multiple objects with the parent. You can even use the same code from above, you just have to remove the unique constraint from the migration script. I‚Äôll add some grouping feature to this todo example.</p><pre><code class="language-swift">// todo group model
final class Group: Model, Content {

    static let schema = "groups"

    @ID() var id: UUID?
    @Field(key: .name) var name: String
    @Children(for: \.$group) var todos: [Todo]

    init() { }

    init(id: UUID? = nil, name: String) {
        self.id = id
        self.name = name
    }
}

// extended todo model
final class Todo: Model, Content {
    //...other fields
    @Parent(key: .groupId) var group: Group
    @Children(for: \.$todo) var details: [Detail]

    init() { }

    init(id: UUID? = nil,
         title: String,
         status: Status = .pending,
         labels: Labels = [],
         due: Date? = nil,
         groupId: UUID)
    {
        self.id = id
        self.title = title
        self.status = status
        self.labels = labels
        self.due = due
        self.$group.id = groupId
    }
}

// migration
struct CreateTodo: Migration {
    
    func prepare(on database: Database) -> EventLoopFuture<Void> {
        database.eventLoop.flatten([
            database.schema(Group.schema)
                .id()
                .field(.name, .string, .required)
                .create(),
            database.schema(Todo.schema)
                .id()
                .field(.title, .string, .required)
                .field(.status, .string, .required)
                .field(.labels, .int, .required)
                .field(.due, .datetime)
                .field(. groupId, .uuid, .required)
                .foreignKey(.groupId, references: Group.schema, .id)
                .create(),
            database.schema(Detail.schema)
                .id()
                .field(. todoId, .uuid, .required)
                .foreignKey(.todoId, references: Todo.schema, .id, onDelete: .cascade, onUpdate: .noAction)
                .field(.description, .string, .required)
                .unique(on: .todoId) //enforce a one-to-one relation
                .create(),
            Group(name: "Default").create(on: database),
        ])
    }

    func revert(on database: Database) -> EventLoopFuture<Void> {
        database.eventLoop.flatten([
            database.schema(Detail.schema).delete(),
            database.schema(Todo.schema).delete(),
            database.schema(Group.shcema).delete(),
        ])
    }
}
</code></pre><p>From now on, you‚Äôll have to insert the todos into a group. It‚Äôs ok to create a default one in the migration script, so later on it‚Äôs possible to get the id reference of the pre-existing group.</p><pre><code class="language-swift">// fetch default group & add a new todo
Group.query(on: req.db)
.first()
.flatMap { group in
    Todo(title: "This belongs to a group", groupId: group!.id!).create(on: app.db)
}
// eager load todos in the group
Group.query(on: req.db)
    .with(\.$todos)
    .all()
.whenSuccess { groups in
    for group in groups {
        print(group.name)
        print(group.todos.map { "- \($0.title)" }.joined(separator: "\n"))
    }
}
</code></pre><p>If you want to change a parent, you can simply set the new identifier using the <code>.$id</code> syntax. Don‚Äôt forget to call update or save on the object, since it‚Äôs not enough just to update the relation in memory, but you have to persist everything back to the database. üí°</p><h3>Many-to-many relations</h3><p>You can create an association between two tables by using a third one that stores foreign keys from both of the original tables. Sounds fun? Welcome to the world of many-to-many relations. They are useful if you want to build a tagging system or a recipe book with ingredients.</p><p>Again, Bastian Inuk has a great post about <a href="https://www.inuk.blog/fluent-in-siblings/" target="_blank">how to use siblings in Fluent 4</a>. I just want to add one extra thing here: you can store additional information on the pivot table. I‚Äôm not going to show you this time how to associate ingredients with recipes & amounts, but I‚Äôll put some tags on the todo items with an important flag option. Thanks buddy! üòú</p><pre><code class="language-swift">extension FieldKey {
    static var name: Self { "name" }
    static var todoId: Self { "todo_id" }
    static var tagId: Self { "tag_id" }
    static var important: Self { "important" }
}

// Tag.swift
final class Tag: Model, Content {

    static let schema = "tags"

    @ID() var id: UUID?
    @Field(key: .name) var name: String
    @Siblings(through: TodoTags.self, from: \.$tag, to: \.$todo) var todos: [Todo]
    
    init() { }

    init(id: UUID? = nil, name: String) {
        self.id = id
        self.name = name
    }
}

// a cross table for the relation between the todos and the tags
final class TodoTags: Model {

    static let schema = "todo_tags"
    
    @ID() var id: UUID?
    @Parent(key: .todoId) var todo: Todo
    @Parent(key: .tagId) var tag: Tag
    @Field(key: .important) var important: Bool
    
    init() {}
    
    init(todoId: UUID, tagId: UUID, important: Bool) {
        self.$todo.id = todoId
        self.$tag.id = tagId
        self.important = important
    }
}

// Todo.swift property extension
//...
@Siblings(through: TodoTags.self, from: \.$todo, to: \.$tag) var tags: [Tag]
//...

// the migration script extension
//...
database.schema(Tag.schema)
    .id()
    .field(.name, .string, .required)
    .create(),
database.schema(TodoTags.schema)
    .id()
    .field(.todoId, .uuid, .required)
    .field(.tagId, .uuid, .required)
    .field(.important, .bool, .required)
    .create(),
//...
database.schema(Tag.schema).delete(),
database.schema(TodoTags.schema).delete(),
//...
</code></pre><p>The only new thing here is the siblings property wrapper which defines the connection between the two tables. It‚Äôs awesome that Fluent can handle these complex relations in such a nice way.</p><blockquote><p>WARN: The code snippet below is for educational purposes only, you should never use the <code>.wait()</code> method in a real-world application, use futures & promises instead.</p></blockquote><p>Finally we‚Äôre able to tag our todo items, plus we can mark some of them as important. üéä</p><pre><code class="language-swift">let defaultGroup = try Group.query(on: app.db).first().wait()!

let shoplist = Group(name: "Shoplist")
let project = Group(name: "Awesome Fluent project")
try [shoplist, project].create(on: app.db).wait()

let family = Tag(name: "family")
let work = Tag(name: "family")
try [family, work].create(on: app.db).wait()

let smoothie = Todo(title: "Make a smoothie",
                    status: .pending,
                    labels: [.purple],
                    due: Date(timeIntervalSinceNow: 3600),
                    groupId: defaultGroup.id!)

let apples = Todo(title: "Apples", groupId: shoplist.id!)
let bananas = Todo(title: "Bananas", groupId: shoplist.id!)
let mango = Todo(title: "Mango", groupId: shoplist.id!)

let kickoff = Todo(title: "Kickoff meeting",
                   status: .completed,
                   groupId: project.id!)

let code = Todo(title: "Code in Swift",
                labels: [.green],
                groupId: project.id!)

let deadline = Todo(title: "Project deadline",
                    labels: [.red],
                    due: Date(timeIntervalSinceNow: 86400 * 7),
                    groupId: project.id!)

try [smoothie, apples, bananas, mango, kickoff, code, deadline].create(on: app.db).wait()

let familySmoothie = TodoTags(todoId: smoothie.id!, tagId: family.id!, important: true)
let workDeadline = TodoTags(todoId: deadline.id!, tagId: work.id!, important: false)

try [familySmoothie, workDeadline].create(on: app.db).wait()
</code></pre><p>That‚Äôs it, now we‚Äôre ready with our awesome todo application. üòé</p><h3>Conclusion</h3><p>Fluent is a crazy powerful tool. You can easily make the switch between the available drivers. You don‚Äôt even have to write SQL if you are using an ORM tool, but only Swift code, which is nice.</p><p>Server side Swift and all the related tools are evolving fast. The whole Vapor community is doing such a great job. I hope this article will help you to understand Fluent way better. üíß</p>
        
    </section>
    
    <h2>Next</h2>
    
    <h2>Prev</h2>
        <div class="post card">
            <a href="/posts/hummingbird-routing-and-requests/" target="">
                <figure>
                    <picture>
                        <img
                            src=""
                            alt=""
                            title=""
                        >
                    </picture>
                </figure>
                <section>
                    <time datetime="2023-03-17 16:20:00">2023-03-17 16:20:00</time>
                    <h2 class="title">Hummingbird routing and requests</h2>
                </section>
                <p>Beginner&#39;s guide to learn all about routing and request handling using the Hummingbird server-side Swift framework.</p>
            </a>
        
            
            
        
        </div>
    
    <h2>Related</h2>
    Empty.
    
    <h2>More by author(s)</h2>
    Empty.

</article>

    </main>

    <footer id="page-footer">
        <section class="content-wrapper">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
    
            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p>
                <a href="https://binarybirds.com/">Home</a> ¬∑
                <a href="mailto:binarybirdsofficial@gmail.com">Email</a> ¬∑
                <a href="https://github.com/binarybirds/">GitHub</a> ¬∑
                <a href="https://x.com/tiborbodecs">Twitter</a> ¬∑
                <a href="/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="/sitemap.xml" target="_blank">Sitemap</a>
            </p>
    
            <p class="small"> &copy; 2022 - 2024.</p>
        </section>
    </footer>
</body>
</html>
