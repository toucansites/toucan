<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Beginners guide to functional Swift - </title>
    <meta name="description" content="The one and only tutorial that you&#39;ll ever need to learn higher order functions like: map, flatMap, compactMap, reduce, filter and more.">
    
    <meta property="og:url" content="/posts/beginners-guide-to-functional-swift/">
    <meta property="og:title" content="Beginners guide to functional Swift - ">
    <meta property="og:description" content="The one and only tutorial that you&#39;ll ever need to learn higher order functions like: map, flatMap, compactMap, reduce, filter and more.">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Beginners guide to functional Swift - ">
    <meta name="twitter:description" content="The one and only tutorial that you&#39;ll ever need to learn higher order functions like: map, flatMap, compactMap, reduce, filter and more.">
    
    <link rel="stylesheet" href="/css/global.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">

    <link rel="shortcut icon" href="/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-touch-icon-180x180.png">

</head>

<body>
    <header id="navigation">
        <a id="site-logo" href="">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
        </a>
    
        <nav id="primary-menu">
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/">Home</a>
                <a href="/blog/">Blog</a>
                <a href="/posts/pages/1/">Posts</a>
                <a href="/authors/">Authors</a>
                <a href="/tags/">Tags</a>
                <a href="/about/">About</a>
            </div>
        </nav>
    
        <nav id="secondary-menu">
            <input type="checkbox" id="secondary-menu-button" name="menu-button" class="menu-button">
            <label for="secondary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="1"></circle>
                    <circle cx="12" cy="5" r="1"></circle>
                    <circle cx="12" cy="19" r="1"></circle>
                </svg>
            </label>
            <div class="menu-items right">
                <a href="#">My account</a>
                <a href="/">Logout</a>
            </div>
        </nav>
    </header>
        
    <main>

<article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2019-02-05 16:20:00">2019-02-05 16:20:00</time>
            <h1 class="title">Beginners guide to functional Swift</h1>
            <p class="excerpt">The one and only tutorial that you&#39;ll ever need to learn higher order functions like: map, flatMap, compactMap, reduce, filter and more.</p>
        </section>
        
    </header>

    <section id="contents" class="content-wrapper">
    
    <h2>Functional programming explained</h2><p>First of all let me emphasize one thing:</p><blockquote><p>Do not be afraid of functional programming!</p></blockquote><p>Even if you are a beginner developer, youâ€™ll see that <a href="https://en.wikipedia.org/wiki/Functional_programming" target="_blank">functional programming</a> is not so hard that you might imagine. If you only learn the basics, itâ€™ll save you lots of time & helps you to write way better applications. The main concept of the FP paradigm is to eliminate mutable states and data, by using <a href="https://docs.swift.org/swift-book/LanguageGuide/Functions.html" target="_blank">functions</a> in a special way. ğŸ’«</p><h3>First-class functions</h3><p>If a programming language treats functions as <a href="https://en.wikipedia.org/wiki/First-class_citizen" target="_blank">first-class citizens</a> (same behavior as weâ€™d expect from a type) we say that it has first class functions.</p><blockquote><p>This means the language supports passing functions as arguments to other functions, returning them as the values from other functions, and assigning them to variables or storing them in data structures.</p></blockquote><p>In Swift you can use function pointers, <a href="https://medium.com/swift-india/functional-swift-closures-67459b812d0" target="_blank">closures</a> (anonymous functions), so yes, Swift is pretty much designed to be a real functional language. Quick sample time:</p><pre><code class="language-swift">// an old-school function
func hello() {
    print("Hello!")
}

// it's a block!
let hi: () -> Void = {
    print("Hi!")
}

// this points to a function
let function = hello
// this is a copy of the closure
let block = hi

hello() // simple function call
function() // call through "function pointer"

hi() // simple closure call
block() // closure call through another variable

// closure parameter
func async(completion: () -> Void) {
    // usually we'd do something here first...
    completion()
}

// calling the method with a closure
async(completion: {
    print("Completed.")
})
// trailing closure syntax
async {
    print("Completed.")
}
</code></pre><p>Please note that sometimes I refer to closures as blocks, for the sake of simplicity letâ€™s pretend that theyâ€™re the exact same thing, and donâ€™t go too much into the details. ğŸ™„</p><h3>Function composition, currying and variadic parameters</h3><p><a href="https://en.wikipedia.org/wiki/Function_composition" target="_blank">Composing functions</a> is basically passing the output of a function to another. This is not so interesting, we do it all the time. On the other hand <a href="https://medium.freecodecamp.org/an-introduction-to-swifts-curried-function-e4b55d10a506" target="_blank">currying</a> functions is a more exciting topic. Currying is basically converting functions with multiple arguments into functions with one arguments and a returning function.</p><p>What is <a href="https://en.wikipedia.org/wiki/Currying" target="_blank">currying</a> used for? Well, some say itâ€™s just a syntactic sugar, others say itâ€™s useful, because you can split logic into smaller more specialized chunks. I leave it up to you whether you find currying useful or not, but in my opinion itâ€™s a quite interesting technique, and itâ€™s worth learning the basics of currying. ğŸ›</p><p>Using a <a href="https://en.wikipedia.org/wiki/Variadic_function" target="_blank">variadic parameter</a> means accepting zero or more values of a specified type. So this means you can for example input as many integers as you want by using a variadic Int parameter. Creating a variadic argument is pretty simple, you just have to append three dots after your typeâ€¦ letâ€™s see these things in action:</p><pre><code class="language-swift">// function composition
func increment(_ x: Int) -> Int {
    return x + 1
}
let x = increment(increment(increment(increment(10))))
print(x)


// function currying
func decrement(_ x: Int) -> (Int) -> Int {
     return { $0 * x }
}
let y = decrement(10)(1)
print(y)


// this is a variadic function that accepts a block as a parameter
func variadic(_ blocks: (() -> Void)...) {
    for block in blocks {
        block()
    }
}

// it means you can pass as many parameters as you want...
variadic({ print("a") }, { print("b") }, { print("c") })

// lol, trailing closure syntax works with variadic block params.
variadic {
    print("d")
}
</code></pre><p>Pretty much that was a quick intro to Swift function capabilities. Of course you can add more parameters (but only one variadic parameter is allowed), use generics and many more, but letâ€™s wait just a little bit more, before we dive into the deep water. ğŸŠâ€â™‚ï¸</p><h3>Higher order functions</h3><p>A function is a <a href="https://www.stephanboyer.com/post/115/higher-rank-and-higher-kinded-types" target="_blank">higher order function</a> if at least one of the following rule is satisfied:</p><ul><li>takes one or more functions as arguments</li><li>returns a function as its result.</li></ul><p>In other words, or maybe even in Swift:</p><pre><code class="language-swift">// a function that takes another function as a parameter
func transform(value: Int, _ transformation: (Int) -> Int) -> Int {
    return transformation(value)
}
let x = transform(value: 10) { value -> Int in
    return value * 2
}
print(x)

// a function that returns another function
func increase(withMultiplication shouldMultiply: Bool) -> (Int, Int) -> Int {
    func add(_ x: Int, _ y: Int) -> Int { return x + y }
    func multiply(_ x: Int, _ y: Int) -> Int { return x * y }
    return shouldMultiply ? multiply : add
}

let y = increase(withMultiplication: true)(10, 10)
print(y)
</code></pre><p>So as you can see itâ€™s not like magic, weâ€™re just passing around functions. At first sight the syntax can seem quite complicated, but trust me, itâ€™s not that hard. If you are having trouble, try to define your own typealiases for the function types, thatâ€™ll make the code a little bit more readable. <code>typealias VoidBlock = () -> Void</code> ğŸ‘</p><h3>Generic functions</h3><p>The real problem starts if youâ€™re trying to generalize your higher order functions. With <a href="http://adriaanm.github.io/files/higher.pdf" target="_blank">generics</a> involved, the syntax can look a little bit messy. Generics (aka. <a href="https://en.wikipedia.org/wiki/Parametric_polymorphism" target="_blank">parametric polymorphism</a>) allows us to abstract away regular types. So for example:</p><pre><code class="language-swift">// this only works for integers
func chooseInt(_ x: Int, or y: Int) -> Int {
    return Bool.random() ? x : y
}

// whoa, this is a generic function
func choose<T>(_ x: T, or y: T) -> T {
    return Bool.random() ? x : y
}

let x = chooseInt(1, or: 2)
print(x) // 1 or 2, but who knows this for sure

let y = choose("heads", or: "tails")
print(y) // maybe heads or maybe tails
</code></pre><p>In the example above we abstracted away the integer type with a generic T type, that can be anything. If we call our generic function with a string as a first parameter, all the remaining T types will be used as strings. Does this make any sense? If yes, then congratulations, now you know what are generic functions. ğŸŠ</p><h3>Containers and boxes ğŸ“¦</h3><p>Letâ€™s start with a generic box. You can put any value into the box (itâ€™s just like an ordinary paper box like youâ€™d use in real life), you can always open the box and directly get the value from inside by using the value property.</p><pre><code class="language-swift">struct Box<T> {

    let value: T

    init(_ value: T) {
        self.value = value
    }
}

let x = Box<Int>(360)
print(x.value)
</code></pre><p>Next continue with a little bit more theory, but I promise Iâ€™ll keep things very short, just because <a href="https://x.com/xenadu02" target="_blank">Russ Bishop</a> already explained <a href="http://www.russbishop.net/monoids-monads-and-functors" target="_blank">functors, applicatives and monads in plain English</a>. Iâ€™ll try to do my best in order to make it <a href="https://www.mokacoding.com/blog/functor-applicative-monads-in-pictures/" target="_blank">even more simple</a>. ğŸ˜‰</p><h3>Functors</h3><blockquote><p>Functors are containers you can call map on.</p></blockquote><p>Challenge accepted! Letâ€™s make a functor from our box type, but what exactly does <a href="https://medium.com/@JLHLonline/a-world-beyond-swift-maps-f73397d4504" target="_blank">map</a>? Well, it basically transforms a value into another. You can provide your own transformation method, where youâ€™ll receive the original value as a parameter and you have to return a â€œnewâ€ value form the same or a different type. Code time!</p><pre><code class="language-swift">extension Box {
    func map<U>(_ transformation: (T) -> U) -> Box<U> {
        return Box<U>(transformation(self.value))
    }
}

let x = Box<Int>(360)
let y = x.map { "\($0) degrees" }
print(y.value)
</code></pre><p>So map is just a generic higher order function! Just a higher order functionâ€¦ ğŸ¤” Just a function passed into another function. Oh, this is only possible, because Swift supports first-class functions! Now you get it! Nothing magical, just functions!</p><h3>Monads</h3><blockquote><p>Monads are containers you can call flatMap on.</p></blockquote><p>This one is ridiculously easy. flatMap is a function that transforms a value, then re-wrap it in the original container type. Itâ€™s like map, but you have to provide the container inside your transformation function. Iâ€™ll show you the implementation:</p><pre><code class="language-swift">extension Box {
    func flatMap<U>(_ transformation: (T) -> Box<U>) -> Box<U> {
        return transformation(self.value)
    }
}

let x = Box<Int>(360)
let y = x.flatMap { Box<String>("\($0) degrees") }
print(y.value)
</code></pre><p>Are you ready for something more complicated? ğŸ˜…</p><h3>Applicatives</h3><p>An <a href="https://kandelvijaya.com/2018/03/25/functorapplicativemonad/#orgff1f53e" target="_blank">applicative</a> lets you put the transformation function inside a container. So you have to unwrap your transformation function first, only after you can apply the function into the wrapped value. That means you have to â€œunboxâ€ the value as well, before the transformation. Explaining things is a though job, let me try in Swift:</p><pre><code class="language-swift">extension Box {
    func apply<U>(_ transformation: Box<(T) -> U>) -> Box<U> {
        return Box<U>(transformation.value(self.value))
    }
}

let x = Box<Int>(360)

let transformation = Box<((Int) -> String)>({ x -> String in
    return "\(x) degrees"
})

let y = x.apply(transformation)
print(y.value)
</code></pre><p>As you can see it all depends on the container, so if youâ€™d like to extend the Optional enum with an apply function thatâ€™d look a little different. Containerization is hard! ğŸ¤ª</p><h3>Quick recap:</h3><ul><li>Container = M</li><li>Functor = map(f: T -> U) -> M</li><li>Monad = flatMap(f: T -> M) -> M</li><li>Applicative = apply(f: M U)>) -> M</li></ul><h3>Higher kinded types</h3><blockquote><p>The idea of higher-rank types is to make polymorphic functions first-class</p></blockquote><p>Currently this is not implemented in the Swift programming language, and itâ€™s <a href="https://forums.swift.org/t/questions-about-the-future-of-protocols-with-associated-types/14784/10" target="_blank">NOT going to be part of the Swift 5 release</a>, but you can <a href="https://stackoverflow.com/questions/52905485/how-to-declare-protocol-for-hkt-in-swift" target="_blank">simulate HKT functionality</a> in Swift with some tricks. Honestly speaking I really donâ€™t want to talk more about <a href="https://stackoverflow.com/questions/6246719/what-is-a-higher-kinded-type-in-scala" target="_blank">higher kinded types</a> now, because itâ€™s a really <a href="https://typelevel.org/blog/2016/08/21/hkts-moving-forward.html" target="_blank">hardcore topic</a>, maybe in the next <a href="https://five.agency/functional-programming-in-swift/" target="_blank">functional programming</a> tutorial, if youâ€™d like to have more like this. ğŸ˜‰</p><h3>Futures</h3><p>Letâ€™s talk a little bit about <a href="http://dist-prog-book.com/chapter/2/futures.html" target="_blank">futures</a>. By definition they are read-only references to a yet-to-be-computed value. Another words: future is a placeholder object for a result that does not exists yet. This can be super useful when it comes to asynchronous programming. Have you ever heard about the <a href="https://blog.hellojs.org/asynchronous-javascript-from-callback-hell-to-async-and-await-9b9ceb63c8e8" target="_blank">callback hell</a>? ğŸ˜ˆ</p><p>A future is basically a generic result wrapper combined with callbacks and some extra state management. A future is both a functor and a <a href="https://broomburgo.github.io/fun-ios/post/why-monads/" target="_blank">monad</a>, this means that you can usually call both map & flatMap on it, but because of the read-only nature of futures you usually have to make a <a href="https://stackoverflow.com/questions/14541975/whats-the-difference-between-a-future-and-a-promise" target="_blank">promise</a> in order to create a new future object. You can find a really nice implementation in <a href="https://github.com/apple/swift-nio/blob/master/Sources/NIO/EventLoopFuture.swift" target="_blank">SwiftNIO</a>. ğŸ˜</p><h3>Promises</h3><blockquote><p>A promise is a writable, single-assignment container, which completes a future.</p></blockquote><p>In a nutshell, you have to make promises, instead of futures, because futures are read-only by design. The promise is the only object that can complete a future (normally only once). We can say that the result of a future will always be set by someone else (private result variable), while the result of a promise (underlying future) will be set by you, since it has a public reject & resolve methods. ğŸš§</p><p>Some promises also implement the future interface, so this means that you can directly call map, flatMap (usually both called as a simple overloaded then method) on a promise.</p><p>Are you Ready for some functional Swift code?</p><h2>Functional Programming in Swift 5</h2><p>Itâ€™s time to practice what weâ€™ve learned. In this section Iâ€™ll go through the most popular functional methods in Swift 5 and show you some of the best practices.</p><h3>map</h3><p>The map function in Swift works on all the <a href="https://swiftdoc.org/v4.2/protocol/sequence/" target="_blank">Sequence</a> types plus the brand new <a href="https://theswiftdev.com/2019/01/28/how-to-use-the-result-type-to-handle-errors-in-swift/" target="_blank">Result type in Swift</a> also has a map function, so you can transform values on these types as you want, which is quite nice in some cases. Here are a few examples:</p><pre><code class="language-swift">// array
let numbers = Array(0...100)
numbers.map { $0 * 10 } // 0, 10, 20 ... 1000
numbers.map(String.init) // "0", "1", "2" ... "100"


// dictionary
let params: [String: Any] = [
    "sort": "name",
    "order": "desc",
    "limit": 20,
    "offset": 2,
]

// mapValues is basically map for the dictionary values
let queryItems = params.mapValues { "\($0)" }
                       .map(URLQueryItem.init)


// set
let fruits = Set<String>(arrayLiteral: "apple", "banana", "pear")
fruits.map { $0.capitalized }

// range
(0...100).map(String.init)
</code></pre><h3>flatMap</h3><p>The flatMap method is also available on most of the types that implements the map functionality. Essentially flatMap does the following thing: it maps and flattens. This means youâ€™ll get the flattened array of subarrays. Let me show you how it works:</p><pre><code class="language-swift">// flatMap
let groups = [
    "animals": ["ğŸ”", "ğŸ¦Š", "ğŸ°", "ğŸ¦"],
    "fruits": ["ğŸ", "ğŸ‰", "ğŸ“", "ğŸ¥"]
]
let emojis = groups.flatMap { $0.value }
// "ğŸ”", "ğŸ¦Š", "ğŸ°", "ğŸ¦", "ğŸ", "ğŸ‰", "ğŸ“", "ğŸ¥"
</code></pre><h3>compactMap</h3><p>So whatâ€™s the deal with <a href="https://www.avanderlee.com/swift/compactmap-flatmap-differences-explained/" target="_blank">flatMap vs compactMap</a>? In the past flatMap could be used to remove optional elements from arrays, but from Swift 4.1 there is a new function called compactMap which should be used for this purpose. The compiler will give you a warning to <a href="https://useyourloaf.com/blog/replacing-flatmap-with-compactmap/" target="_blank">replace flatMap with compactMap</a> in most of the cases.</p><pre><code class="language-swift">// compactMap
[1, nil, 3, nil, 5, 6].compactMap { $0 } // 1, 3, 5, 6

let possibleNumbers = ["1", "two", "3", "four", "five", "6"]
possibleNumbers.compactMap { Int($0) } //1, 3, 6
</code></pre><h3>reduce</h3><p>The reduce method is a powerful tool. It can be used to combine all the elemens from a collection into a single one. For example you can use it to summarize elements, but itâ€™s also quite handy for joining elements together with an initial component.</p><pre><code>let sum = (0...100).reduce(0, +)
print(sum) //5050

let cats = ["ğŸ¦", "ğŸ¯", "ğŸ±"]
cats.reduce("Cats: ") { sum, cat in "\(sum)\(cat)"} // Cats: ğŸ¦ğŸ¯ğŸ±


let basketballScores = [
    "team one": [2,2,3,2,3],
    "team two": [3,2,3,2,2],
]

let points = basketballScores.reduce(0) { sum, element in
    return sum + element.value.reduce(0, +)
}
print(points) // 24 (team one + team two scores together)
</code></pre><h3>filter</h3><p>You can filter <a href="https://medium.com/@JLHLonline/superpowered-sequences-a009ccc1ae43" target="_blank">sequences</a> with the <a href="https://medium.com/@abhimuralidharan/higher-order-functions-in-swift-filter-map-reduce-flatmap-1837646a63e8" target="_blank">filter</a> method, itâ€™s pretty obvious! You can define a condition block for each element, and if the condition is true, the given element will be included in the result. Itâ€™s like looping through elements & picking some. ğŸ¤ª</p><pre><code class="language-swift">let evenNumbers = (0...100).filter { $0.isMultiple(of: 2) }
let oddNumbers = (0...100).filter { !evenNumbers.contains($0) }

let numbers = [
    "odd": oddNumbers,
    "even": evenNumbers,
]

let luckyThirteen = numbers
.filter { element in
    return element.key == "odd"
}
.mapValues { element in
    return element.filter { $0 == 13 }
}
</code></pre><h3>promises</h3><p>I love promises, and you should learn them too if you donâ€™t know how they work. Otherwise you can still go with the <a href="https://theswiftdev.com/2018/07/10/ultimate-grand-central-dispatch-tutorial-in-swift/" target="_blank">Dispatch framework</a>, but I prefer promises, because passing variables around is way more easy by using a <a href="https://github.com/corekit/promises" target="_blank">promise framework</a>.</p><pre><code class="language-swift">Promise<String> { fulfill, reject in
    fulfill("Hello")
}
.thenMap { result in
    return result + " World!"
}
.then { result in
    return Promise<String>(value: result)
}
.tap { result in
    print("debug: \(result)")
}
.onSuccess(queue: .main) { result in
    print(result)
}
.onFailure { error in
    print(error.localizedDescription)
}
.always {
    print("done!")
}
</code></pre><h2>Whatâ€™s next?</h2><p>There is a game for practicing functional methods! Itâ€™s called <a href="https://david-peter.de/cube-composer/" target="_blank">cube composer</a>, and it is totally awesome and fun! Just play a few rounds, you wonâ€™t regret it! ğŸ®</p>
        
    </section>
    
    <h2>Next</h2>
    
    <h2>Prev</h2>
        <div class="post card">
            <a href="/posts/hummingbird-routing-and-requests/" target="">
                <figure>
                    <picture>
                        <img
                            src=""
                            alt=""
                            title=""
                        >
                    </picture>
                </figure>
                <section>
                    <time datetime="2023-03-17 16:20:00">2023-03-17 16:20:00</time>
                    <h2 class="title">Hummingbird routing and requests</h2>
                </section>
                <p>Beginner&#39;s guide to learn all about routing and request handling using the Hummingbird server-side Swift framework.</p>
            </a>
        
            
            
        
        </div>
    
    <h2>Related</h2>
    Empty.
    
    <h2>More by author(s)</h2>
    Empty.

</article>

    </main>

    <footer id="page-footer">
        <section class="content-wrapper">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
    
            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p>
                <a href="https://binarybirds.com/">Home</a> Â·
                <a href="mailto:binarybirdsofficial@gmail.com">Email</a> Â·
                <a href="https://github.com/binarybirds/">GitHub</a> Â·
                <a href="https://x.com/tiborbodecs">Twitter</a> Â·
                <a href="/rss.xml" target="_blank">RSS</a> Â·
                <a href="/sitemap.xml" target="_blank">Sitemap</a>
            </p>
    
            <p class="small"> &copy; 2022 - 2024.</p>
        </section>
    </footer>
</body>
</html>
