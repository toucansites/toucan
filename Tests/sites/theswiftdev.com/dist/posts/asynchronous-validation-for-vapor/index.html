<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Asynchronous validation for Vapor - </title>
    <meta name="description" content="Learn how to validate input data using an async technique. Unified request validation API for your server side Swift app.">
    
    <meta property="og:url" content="/posts/asynchronous-validation-for-vapor/">
    <meta property="og:title" content="Asynchronous validation for Vapor - ">
    <meta property="og:description" content="Learn how to validate input data using an async technique. Unified request validation API for your server side Swift app.">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Asynchronous validation for Vapor - ">
    <meta name="twitter:description" content="Learn how to validate input data using an async technique. Unified request validation API for your server side Swift app.">
    
    <link rel="stylesheet" href="/css/global.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">

    <link rel="shortcut icon" href="/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-touch-icon-180x180.png">

</head>

<body>
    <header id="navigation">
        <a id="site-logo" href="">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
        </a>
    
        <nav id="primary-menu">
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/">Home</a>
                <a href="/blog/">Blog</a>
                <a href="/posts/pages/1/">Posts</a>
                <a href="/authors/">Authors</a>
                <a href="/tags/">Tags</a>
                <a href="/about/">About</a>
            </div>
        </nav>
    
        <nav id="secondary-menu">
            <input type="checkbox" id="secondary-menu-button" name="menu-button" class="menu-button">
            <label for="secondary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="1"></circle>
                    <circle cx="12" cy="5" r="1"></circle>
                    <circle cx="12" cy="19" r="1"></circle>
                </svg>
            </label>
            <div class="menu-items right">
                <a href="#">My account</a>
                <a href="/">Logout</a>
            </div>
        </nav>
    </header>
        
    <main>

<article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2017-10-10 16:20:00">2017-10-10 16:20:00</time>
            <h1 class="title">Asynchronous validation for Vapor</h1>
            <p class="excerpt">Learn how to validate input data using an async technique. Unified request validation API for your server side Swift app.</p>
        </section>
        
    </header>

    <section id="contents" class="content-wrapper">
    
    <h2>Vapor‚Äôs validation API</h2><p>The very first thing I‚Äôd like to show you is an issue that I have with the current <a href="https://docs.vapor.codes/4.0/validation/" target="_blank">validation</a> API for the Vapor framework. I always wanted to use it, because I really like the validator functions but unfortunately the API lacks quite a lot of features that are crucial for my needs.</p><p>If we take a look at our previously created <a href="https://theswiftdev.com/declarative-unit-tests-for-vapor/" target="_blank">Todo example</a> code, you might remember that we‚Äôve only put some validation on the create API endpoint. That‚Äôs not very safe, we should fix this. I‚Äôm going to show you how to validate endpoints using the built-in API, to see what‚Äôs the issue with it. ü•≤</p><p>In order to demonstrate the problems, we‚Äôre going to add a new Tag model to our Todo items.</p><pre><code class="language-swift">import Vapor
import Fluent

final class TagModel: Model {

    static let schema = "tags"
    static let idParamKey = "tagId"
   
    struct FieldKeys {
        static let name: FieldKey = "name"
        static let todoId: FieldKey = "todo_id"
    }
    
    @ID(key: .id) var id: UUID?
    @Field(key: FieldKeys.name) var name: String
    @Parent(key: FieldKeys.todoId) var todo: TodoModel
    
    init() { }
    
    init(id: UUID? = nil, name: String, todoId: UUID) {
        self.id = id
        self.name = name
        self.$todo.id = todoId
    }
}
</code></pre><p>So the main idea is that we‚Äôre going to be able to tag our todo items and save the todoId reference for each tag. This is not going to be a global tagging solution, but more like a simple tag system for demo purposes. The relation will be automatically validated on the database level (if the db driver supports it), since we‚Äôre going to put a foreign key constraint on the todoId field in the migration.</p><pre><code class="language-swift">import Fluent

struct TagMigration: Migration {

    func prepare(on db: Database) -> EventLoopFuture<Void> {
        db.schema(TagModel.schema)
            .id()
            .field(TagModel.FieldKeys.name, .string, .required)
            .field(TagModel.FieldKeys.todoId, .uuid, .required)
            .foreignKey(TagModel.FieldKeys.todoId, references: TodoModel.schema, .id)
            .create()
    }

    func revert(on db: Database) -> EventLoopFuture<Void> {
        db.schema(TagModel.schema).delete()
    }
}
</code></pre><p>It is important to mention this again: NOT every single database supports foreign key validation out of the box. This is why it will be extremely important to validate our input data. If we let users to put random todoId values into the database that can lead to data corruption and other problems.</p><p>Now that we have our database model & migration, here‚Äôs how the API objects will look like. You can put these into the TodoApi target, since these DTOs could be shared with a client side library. üì≤</p><pre><code class="language-swift">import Foundation

public struct TagListObject: Codable {
    
    public let id: UUID
    public let name: String

    public init(id: UUID, name: String) {
        self.id = id
        self.name = name
    }
}

public struct TagGetObject: Codable {
    
    public let id: UUID
    public let name: String
    public let todoId: UUID
    
    public init(id: UUID, name: String, todoId: UUID) {
        self.id = id
        self.name = name
        self.todoId = todoId
        
    }
}

public struct TagCreateObject: Codable {

    public let name: String
    public let todoId: UUID
    
    public init(name: String, todoId: UUID) {
        self.name = name
        self.todoId = todoId
    }
}

public struct TagUpdateObject: Codable {
    
    public let name: String
    public let todoId: UUID
    
    public init(name: String, todoId: UUID) {
        self.name = name
        self.todoId = todoId
    }
}

public struct TagPatchObject: Codable {

    public let name: String?
    public let todoId: UUID?
    
    public init(name: String?, todoId: UUID?) {
        self.name = name
        self.todoId = todoId
    }
}
</code></pre><p>Next we extend our <code>TagModel</code> to support CRUD operations, if you followed my first tutorial about <a href="https://theswiftdev.com/how-to-design-type-safe-restful-apis-using-swift-and-vapor/" target="_blank">how to build a REST API using Vapor</a>, this should be very familiar, if not please read it first. üôè</p><pre><code class="language-swift">import Vapor
import TodoApi

extension TagListObject: Content {}
extension TagGetObject: Content {}
extension TagCreateObject: Content {}
extension TagUpdateObject: Content {}
extension TagPatchObject: Content {}

extension TagModel {
    
    func mapList() -> TagListObject {
        .init(id: id!, name: name)
    }

    func mapGet() -> TagGetObject {
        .init(id: id!, name: name, todoId: $todo.id)
    }
    
    func create(_ input: TagCreateObject) {
        name = input.name
        $todo.id = input.todoId
    }
        
    func update(_ input: TagUpdateObject) {
        name = input.name
        $todo.id = input.todoId
    }
    
    func patch(_ input: TagPatchObject) {
        name = input.name ?? name
        $todo.id = input.todoId ?? $todo.id
    }
}
</code></pre><p>The tag controller is going to look very similar to the todo controller, for now we won‚Äôt validate anything, the following snippet is all about having a sample code that we can fine tune later on.</p><pre><code class="language-swift">import Vapor
import Fluent
import TodoApi

struct TagController {

    private func getTagIdParam(_ req: Request) throws -> UUID {
        guard let rawId = req.parameters.get(TagModel.idParamKey), let id = UUID(rawId) else {
            throw Abort(.badRequest, reason: "Invalid parameter `\(TagModel.idParamKey)`")
        }
        return id
    }

    private func findTagByIdParam(_ req: Request) throws -> EventLoopFuture<TagModel> {
        TagModel
            .find(try getTagIdParam(req), on: req.db)
            .unwrap(or: Abort(.notFound))
    }

    // MARK: - endpoints
    
    func list(req: Request) throws -> EventLoopFuture<Page<TagListObject>> {
        TagModel.query(on: req.db).paginate(for: req).map { $0.map { $0.mapList() } }
    }
    
    func get(req: Request) throws -> EventLoopFuture<TagGetObject> {
        try findTagByIdParam(req).map { $0.mapGet() }
    }

    func create(req: Request) throws -> EventLoopFuture<Response> {
        let input = try req.content.decode(TagCreateObject.self)

        let tag = TagModel()
        tag.create(input)
        return tag
            .create(on: req.db)
            .map { tag.mapGet() }
            .encodeResponse(status: .created, for: req)
    }
    
    func update(req: Request) throws -> EventLoopFuture<TagGetObject> {
        let input = try req.content.decode(TagUpdateObject.self)

        return try findTagByIdParam(req)
            .flatMap { tag in
                tag.update(input)
                return tag.update(on: req.db).map { tag.mapGet() }
            }
    }
    
    func patch(req: Request) throws -> EventLoopFuture<TagGetObject> {
        let input = try req.content.decode(TagPatchObject.self)

        return try findTagByIdParam(req)
            .flatMap { tag in
                tag.patch(input)
                return tag.update(on: req.db).map { tag.mapGet() }
            }
    }

    func delete(req: Request) throws -> EventLoopFuture<HTTPStatus> {
        try findTagByIdParam(req)
            .flatMap { $0.delete(on: req.db) }
            .map { .ok }
    }
}
</code></pre><p>Of course we could use a <a href="https://theswiftdev.com/a-generic-crud-solution-for-vapor-4/" target="_blank">generic CRUD controller</a> class that could highly reduce the amount of code required to create similar controllers, but that‚Äôs a different topic. So we just have to register these newly created functions using a router.</p><pre><code class="language-swift">import Vapor

struct TagRouter: RouteCollection {

    func boot(routes: RoutesBuilder) throws {

        let tagController = TagController()
        
        let id = PathComponent(stringLiteral: ":" + TagModel.idParamKey)
        let tagRoutes = routes.grouped("tags")
        
        tagRoutes.get(use: tagController.list)
        tagRoutes.post(use: tagController.create)
        
        tagRoutes.get(id, use: tagController.get)
        tagRoutes.put(id, use: tagController.update)
        tagRoutes.patch(id, use: tagController.patch)
        tagRoutes.delete(id, use: tagController.delete)
    }
}
</code></pre><p>Also a few more changes in the <code>configure.swift</code> file, since we‚Äôd like to take advantage of the Tag functionality we have to register the migration and the new routes using the TagRouter.</p><pre><code class="language-swift">import Vapor
import Fluent
import FluentSQLiteDriver

public func configure(_ app: Application) throws {

    if app.environment == .testing {
        app.databases.use(.sqlite(.memory), as: .sqlite, isDefault: true)
    }
    else {
        app.databases.use(.sqlite(.file("Resources/db.sqlite")), as: .sqlite)
    }

    app.http.server.configuration.hostname = "192.168.8.103"
    app.migrations.add(TodoMigration())
    app.migrations.add(TagMigration())
    try app.autoMigrate().wait()

    try TodoRouter().boot(routes: app.routes)
    try TagRouter().boot(routes: app.routes)
}
</code></pre><p>One more thing, before we start validating our tags, we have to put a new <code>@Children(for: \.$todo) var tags: [TagModel]</code> property into our <code>TodoModel</code>, so it‚Äôs going to be way more easy to fetch tags.</p><p>If you run the server and try to create a new tag using cURL and a fake UUID, the database query will fail if the db supports foreign keys.</p><pre><code class="language-sh">curl -X POST "http://127.0.0.1:8080/tags/" \
    -H 'Content-Type: application/json' \
    -d '{"name": "test", "todoId": "94234a4a-b749-4a2a-97d0-3ebd1046dbac"}'
</code></pre><p>This is not ideal, we should protect our database from invalid data. Well, first of all we don‚Äôt want to allow empty or too long names, so we should validate this field as well, this can be done using the validation API from the Vapor framework, let me show you how.</p><pre><code class="language-swift">// TagModel+Api.swift
extension TagCreateObject: Validatable {
    public static func validations(_ validations: inout Validations) {
        validations.add("title", as: String.self, is: !.empty)
        validations.add("title", as: String.self, is: .count(...100) && .alphanumeric)
    }
}
// TagController.swift
func create(req: Request) throws -> EventLoopFuture<Response> {
    try TagCreateObject.validate(content: req)
    let input = try req.content.decode(TagCreateObject.self)

    let tag = TagModel()
    tag.create(input)
    return tag
        .create(on: req.db)
        .map { tag.mapGet() }
        .encodeResponse(status: .created, for: req)
}
/* 
curl -X POST "http://127.0.0.1:8080/tags/" \
    -H 'Content-Type: application/json' \
    -d '{"name": "", "todoId": "94234a4a-b749-4a2a-97d0-3ebd1046dbac"}'

{"error":true,"reason":"name is empty"}

/// some other cases:
name: 123
{"error":true,"reason":"name is not a(n) String, name is not a(n) String"}
name: ?
{"error":true,"reason":"name contains '?' (allowed: A-Z, a-z, 0-9)"}
name: very-lenghty-string
{"error":true,"reason":"name is greater than maximum of 100 character(s)"}
*/
</code></pre><p>Ok, it looks great, but this solution lacks a few things:</p><ul><li>You can‚Äôt provide custom error messages</li><li>The detail is always a concatenated result string (if there are multiple errors)</li><li>You can‚Äôt get the error message for a given key (e.g. ‚Äútitle‚Äù: ‚ÄúTitle is required‚Äù)</li><li>Validation happens synchronously (you can‚Äôt validate based on a db query)</li></ul><p>This is very unfortunate, because Vapor has really nice validator functions. You can validate characters (<code>.ascii</code>, <code>.alphanumeric</code>, <code>.characterSet(_:)</code>), various length and range requirements (<code>.empty</code>, <code>.count(_:)</code>, <code>.range(_)</code>), collections (<code>.in(_:)</code>), check null inputs, validate emails and URLs. We should try to validate the todo identifier based on the available todos in the database.</p><p>It is possible to validate todoId‚Äôs by running a query with the input id and see if there is an existing record in our database. If there is no such todo, we won‚Äôt allow the creation (or update / patch) operation. The problem is that we have to put this logic into the controller. üòï</p><pre><code class="language-swift">func create(req: Request) throws -> EventLoopFuture<Response> {
    try TagCreateObject.validate(content: req)
    let input = try req.content.decode(TagCreateObject.self)
    return TodoModel.find(input.todoId, on: req.db)
        .unwrap(or: Abort(.badRequest, reason: "Invalid todo identifier"))
        .flatMap { _ in
            let tag = TagModel()
            tag.create(input)
            return tag
                .create(on: req.db)
                .map { tag.mapGet() }
                .encodeResponse(status: .created, for: req)
        }
}
</code></pre><p>This will do the job, but isn‚Äôt it strange that we are doing validation in two separate places?</p><p>My other problem is that using the validatable protocol means that you can‚Äôt really pass parameters for these validators, so even if you asynchronously fetch some required data and somehow you move the logic inside the validator, the whole process is going to feel like a very hacky solution. ü§ê</p><p>Honestly, am I missing something here? Is this really how the validation system works in the most popular web framework? It‚Äôs quite unbelievable. There must be a better way‚Ä¶ ü§î</p><p>Async input validation<br>This method that I‚Äôm going to show you is already available in Feather CMS, I believe it‚Äôs quite an advanced system compared to Vapor‚Äôs validation API. I‚Äôll show you how I created it, first we start with a protocol that‚Äôll contain the basic stuff needed for validation & result management.</p><pre><code class="language-swift">import Vapor

public protocol AsyncValidator {
    
    var key: String { get }
    var message: String { get }

    func validate(_ req: Request) -> EventLoopFuture<ValidationErrorDetail?>
}

public extension AsyncValidator {

    var error: ValidationErrorDetail {
        .init(key: key, message: message)
    }
}
</code></pre><p>This is a quite simple protocol that we‚Äôre going to be the base of our asynchronous validation flow. The key will be used to just like the same way as Vapor uses validation keys, it‚Äôs basically an input key for a given data object and we‚Äôre going to use this key with an appropriate error message to display detailed validation errors (as an output content).</p><pre><code class="language-swift">import Vapor

public struct ValidationErrorDetail: Codable {

    public var key: String
    public var message: String
    
    public init(key: String, message: String) {
        self.key = key
        self.message = message
    }
}

extension ValidationErrorDetail: Content {}
</code></pre><p>So the idea is that we‚Äôre going to create multiple validation handlers based on this AsyncValidator protocol and get the final result based on the evaluated validators. The validation method can look like magic at first sight, but it‚Äôs just calling the async validator methods if a given key is already invalidated then it‚Äôll skip other validations for that (for obvious reasons), and based on the individual validator results we create a final array including the validation error detail objects. ü§ì</p><pre><code class="language-swift">import Vapor

public struct RequestValidator {

    public var validators: [AsyncValidator]
    
    public init(_ validators: [AsyncValidator] = []) {
        self.validators = validators
    }
    
    /// this is magic, don't touch it
    public func validate(_ req: Request, message: String? = nil) -> EventLoopFuture<Void> {
        let initial: EventLoopFuture<[ValidationErrorDetail]> = req.eventLoop.future([])
        return validators.reduce(initial) { res, next -> EventLoopFuture<[ValidationErrorDetail]> in
            return res.flatMap { arr -> EventLoopFuture<[ValidationErrorDetail]> in
                if arr.contains(where: { $0.key == next.key }) {
                    return req.eventLoop.future(arr)
                }
                return next.validate(req).map { result in
                    if let result = result {
                        return arr + [result]
                    }
                    return arr
                }
            }
        }
        .flatMapThrowing { details in
            guard details.isEmpty else {
                throw Abort(.badRequest, reason: details.map(\.message).joined(separator: ", "))
            }
        }
    }

    public func isValid(_ req: Request) -> EventLoopFuture<Bool> {
        return validate(req).map { true }.recover { _ in false }
    }
}
</code></pre><p>Don‚Äôt wrap your head too much about this code, I‚Äôll show you how to use it right away, but before we could perform a validation using our new tools, we need something that implements the AsyncValidator protocol and we can actually initialize. I have something that I really like in Feather, because it can perform both sync & async validations, of course you can come up with more simple validators, but this is a nice generic solution for most of the cases.</p><pre><code class="language-swift">import Vapor

public struct KeyedContentValidator<T: Codable>: AsyncValidator {

    public let key: String
    public let message: String
    public let optional: Bool

    public let validation: ((T) -> Bool)?
    public let asyncValidation: ((T, Request) -> EventLoopFuture<Bool>)?
    
    public init(_ key: String,
                _ message: String,
                optional: Bool = false,
                _ validation: ((T) -> Bool)? = nil,
                _ asyncValidation: ((T, Request) -> EventLoopFuture<Bool>)? = nil) {
        self.key = key
        self.message = message
        self.optional = optional
        self.validation = validation
        self.asyncValidation = asyncValidation
    }
    
    public func validate(_ req: Request) -> EventLoopFuture<ValidationErrorDetail?> {
        let optionalValue = try? req.content.get(T.self, at: key)

        if let value = optionalValue {
            if let validation = validation {
                return req.eventLoop.future(validation(value) ? nil : error)
            }
            if let asyncValidation = asyncValidation {
                return asyncValidation(value, req).map { $0 ? nil : error }
            }
            return req.eventLoop.future(nil)
        }
        else {
            if optional {
                return req.eventLoop.future(nil)
            }
            return req.eventLoop.future(error)
        }
    }
}
</code></pre><p>The main idea here is that we can pass either a sync or an async validation block alongside the key, message and optional arguments and we perform our validation based on these inputs.</p><p>First we try to decode the generic Codable value, if the value was optional and it is missing we can simply ignore the validators and return, otherwise we should try to call the sync validator or the async validator. Please note that the sync validator is just a convenience tool, because if you don‚Äôt need async calls it‚Äôs more easy to return with a bool value instead of an <code>EventLoopFuture<Bool></code>.</p><p>So, this is how you can validate anything using these new server side Swift validator components.</p><pre><code class="language-swift">func create(req: Request) throws -> EventLoopFuture<Response> {
    let validator = RequestValidator.init([
        KeyedContentValidator<String>.init("name", "Name is required") { !$0.isEmpty },
        KeyedContentValidator<UUID>.init("todoId", "Todo identifier must be valid", nil) { value, req in
            TodoModel.query(on: req.db).filter(\.$id == value).count().map {
                $0 == 1
            }
        },
    ])
    return validator.validate(req).flatMap {
        do {
            let input = try req.content.decode(TagCreateObject.self)
            let tag = TagModel()
            tag.create(input)
            return tag
                .create(on: req.db)
                .map { tag.mapGet() }
                .encodeResponse(status: .created, for: req)
        }
        catch {
            return req.eventLoop.future(error: Abort(.badRequest, reason: error.localizedDescription))
        }
    }
}
</code></pre><p>This seems like a bit more code at first sight, but remember that previously we moved out our validator into a separate method. We can do the exact same thing here and return an array of AsyncValidator objects. Also a ‚Äúreal throwing flatMap EventLoopFuture‚Äù extension method could help us greatly to remove unnecessary do-try-catch statements from our code.</p><p>Anyway, I‚Äôll leave this up for you, but it‚Äôs easy to reuse the same validation for all the CRUD endpoints, for patch requests you can set the optional flag to true and that‚Äôs it. üí°</p><p>I still want to show you one more thing, because I don‚Äôt like the current JSON output of the invalid calls. We‚Äôre going to build a custom error middleware with a custom context object to display more details about what went wrong during the request. We need a validation error content for this.</p><pre><code class="language-swift">import Vapor

public struct ValidationError: Codable {

    public let message: String?
    public let details: [ValidationErrorDetail]
    
    public init(message: String?, details: [ValidationErrorDetail]) {
        self.message = message
        self.details = details
    }
}

extension ValidationError: Content {}
</code></pre><p>This is the format that we‚Äôd like to use when something goes wrong. Now it‚Äôd be nice to support custom error codes while keeping the throwing nature of errors, so for this reason we‚Äôll define a new ValidationAbort that‚Äôs going to contain everything we‚Äôll need for the new error middleware.</p><pre><code class="language-swift">import Vapor

public struct ValidationAbort: AbortError {

    public var abort: Abort
    public var message: String?
    public var details: [ValidationErrorDetail]

    public var reason: String { abort.reason }
    public var status: HTTPStatus { abort.status }
    
    public init(abort: Abort, message: String? = nil, details: [ValidationErrorDetail]) {
        self.abort = abort
        self.message = message
        self.details = details
    }
}
</code></pre><p>This will allow us to throw ValidationAbort objects with a custom Abort & detailed error description. The Abort object is used to set the proper HTTP response code and headers when building the response object inside the middleware. The middleware is very similar to the built-in error middleware, except that it can return more details about the given validation issues.</p><pre><code class="language-swift">import Vapor

public struct ValidationErrorMiddleware: Middleware {

    public let environment: Environment
    
    public init(environment: Environment) {
        self.environment = environment
    }

    public func respond(to request: Request, chainingTo next: Responder) -> EventLoopFuture<Response> {
        return next.respond(to: request).flatMapErrorThrowing { error in
            let status: HTTPResponseStatus
            let headers: HTTPHeaders
            let message: String?
            let details: [ValidationErrorDetail]

            switch error {
            case let abort as ValidationAbort:
                status = abort.abort.status
                headers = abort.abort.headers
                message = abort.message ?? abort.reason
                details = abort.details
            case let abort as Abort:
                status = abort.status
                headers = abort.headers
                message = abort.reason
                details = []
            default:
                status = .internalServerError
                headers = [:]
                message = environment.isRelease ? "Something went wrong." : error.localizedDescription
                details = []
            }

            request.logger.report(error: error)

            let response = Response(status: status, headers: headers)

            do {
                response.body = try .init(data: JSONEncoder().encode(ValidationError(message: message, details: details)))
                response.headers.replaceOrAdd(name: .contentType, value: "application/json; charset=utf-8")
            }
            catch {
                response.body = .init(string: "Oops: \(error)")
                response.headers.replaceOrAdd(name: .contentType, value: "text/plain; charset=utf-8")
            }
            return response
        }
    }
}
</code></pre><p>Based on the given environment we can report the details or hide the internal issues, this is totally up-to-you, for me this approach works the best, because I can always parse the problematic keys and display error messages inside the client apps based on this response.</p><p>We just have to alter one line in the RequestValidator & register our newly created middleware for better error reporting. Here‚Äôs the updated request validator:</p><pre><code class="language-swift">// RequestValidator.swift
// (simply change the throwed object in the flatMapThrowing block)
.flatMapThrowing { details in
    guard details.isEmpty else {
        throw ValidationAbort(abort: Abort(.badRequest, reason: message), details: details)
    }
}

// configure.swift
app.middleware.use(ValidationErrorMiddleware(environment: app.environment))
</code></pre><p>Now if you run the same invalid cURL request, you should get a way better error response.</p><pre><code class="language-sh">curl -i -X POST "http://192.168.8.103:8080/tags/" \
    -H 'Content-Type: application/json' \
    -d '{"name": "eee", "todoId": "94234a4a-b749-4a2a-97d0-3ebd1046dbac"}'

# HTTP/1.1 400 Bad Request
# content-length: 72
# content-type: application/json; charset=utf-8
# connection: keep-alive
# date: Wed, 12 May 2021 14:52:47 GMT
#
# {"details":[{"key":"todoId","message":"Todo identifier must be valid"}]}
</code></pre><p>You can even add a custom message for the request validator when you call the validate function, that‚Äôll be available under the message key inside the output.</p><p>As you can see this is quite a nice way to deal with errors and unify the flow of the entire validation chain. I‚Äôm not saying that Vapor did a bad job with the official validation APIs, but there‚Äôs definitely room for improvements. I really love the wide variety of the <a href="https://docs.vapor.codes/4.0/validation/#validators" target="_blank">available validators</a>, but on the other hand I freakin‚Äô miss this async validation logic from the core framework. ‚ù§Ô∏èüí©</p><p>Another nice thing about this approach is that you can define validator extensions and greatly simplify the amount of Swift code required to perform server side validation.</p><p>I know I‚Äôm not the only one with these issues, and I really hope that this little tutorial will help you create better (and more safe) backend apps using Vapor. I can only say that feel free to improve the validation related code for this Todo project, that‚Äôs a good practice for sure. Hopefully it won‚Äôt be too hard to add more validation logic based on the provided examples. üòâ</p>
        
    </section>
    
    <h2>Next</h2>
    
    <h2>Prev</h2>
        <div class="post card">
            <a href="/posts/hummingbird-routing-and-requests/" target="">
                <figure>
                    <picture>
                        <img
                            src=""
                            alt=""
                            title=""
                        >
                    </picture>
                </figure>
                <section>
                    <time datetime="2023-03-17 16:20:00">2023-03-17 16:20:00</time>
                    <h2 class="title">Hummingbird routing and requests</h2>
                </section>
                <p>Beginner&#39;s guide to learn all about routing and request handling using the Hummingbird server-side Swift framework.</p>
            </a>
        
            
            
        
        </div>
    
    <h2>Related</h2>
    Empty.
    
    <h2>More by author(s)</h2>
    Empty.

</article>

    </main>

    <footer id="page-footer">
        <section class="content-wrapper">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
    
            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p>
                <a href="https://binarybirds.com/">Home</a> ¬∑
                <a href="mailto:binarybirdsofficial@gmail.com">Email</a> ¬∑
                <a href="https://github.com/binarybirds/">GitHub</a> ¬∑
                <a href="https://x.com/tiborbodecs">Twitter</a> ¬∑
                <a href="/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="/sitemap.xml" target="_blank">Sitemap</a>
            </p>
    
            <p class="small"> &copy; 2022 - 2024.</p>
        </section>
    </footer>
</body>
</html>
