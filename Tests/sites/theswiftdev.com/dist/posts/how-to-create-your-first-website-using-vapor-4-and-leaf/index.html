<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>How to create your first website using Vapor 4 and Leaf? - </title>
    <meta name="description" content="Let&#39;s build a web page in Swift. Learn how to use the brand new template engine of the most popular server side Swift framework.">
    
    <meta property="og:url" content="/posts/how-to-create-your-first-website-using-vapor-4-and-leaf/">
    <meta property="og:title" content="How to create your first website using Vapor 4 and Leaf? - ">
    <meta property="og:description" content="Let&#39;s build a web page in Swift. Learn how to use the brand new template engine of the most popular server side Swift framework.">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="How to create your first website using Vapor 4 and Leaf? - ">
    <meta name="twitter:description" content="Let&#39;s build a web page in Swift. Learn how to use the brand new template engine of the most popular server side Swift framework.">
    
    <link rel="stylesheet" href="/css/global.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">

    <link rel="shortcut icon" href="/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-touch-icon-180x180.png">

</head>

<body>
    <header id="navigation">
        <a id="site-logo" href="">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
        </a>
    
        <nav id="primary-menu">
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/">Home</a>
                <a href="/blog/">Blog</a>
                <a href="/posts/pages/1/">Posts</a>
                <a href="/authors/">Authors</a>
                <a href="/tags/">Tags</a>
                <a href="/my-page/">My page</a>
            </div>
        </nav>
    
        <nav id="secondary-menu">
            <input type="checkbox" id="secondary-menu-button" name="menu-button" class="menu-button">
            <label for="secondary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="1"></circle>
                    <circle cx="12" cy="5" r="1"></circle>
                    <circle cx="12" cy="19" r="1"></circle>
                </svg>
            </label>
            <div class="menu-items right">
                <a href="#">My account</a>
                <a href="/">Logout</a>
            </div>
        </nav>
    </header>
        
    <main>

<article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2020-02-13 16:20:00">2020-02-13 16:20:00</time>
            <h1 class="title">How to create your first website using Vapor 4 and Leaf?</h1>
            <p class="excerpt">Let&#39;s build a web page in Swift. Learn how to use the brand new template engine of the most popular server side Swift framework.</p>
        </section>
        
    </header>

    <section id="contents" class="content-wrapper">
    
    <h2>Project setup</h2><p>Start a brand new project by using the Vapor toolbox. If you don‚Äôt know what‚Äôs the toolbox or how to install it, you should read my <a href="https://theswiftdev.com/beginners-guide-to-server-side-swift-using-vapor-4/" target="_blank">beginner‚Äôs guide about Vapor 4</a> first.</p><pre><code class="language-swift">// swift-tools-version:5.3
import PackageDescription

let package = Package(
    name: "myProject",
    platforms: [
       .macOS(.v10_15)
    ],
    dependencies: [
        // üíß A server-side Swift web framework.
        .package(url: "https://github.com/vapor/vapor", from: "4.32.0"),
        .package(url: "https://github.com/vapor/leaf", .exact("4.0.0-tau.1")),
        .package(url: "https://github.com/vapor/leaf-kit", .exact("1.0.0-tau.1.1")),
    ],
    targets: [
        .target(name: "App", dependencies: [
            .product(name: "Leaf", package: "leaf"),
            .product(name: "Vapor", package: "vapor"),
        ]),
        .target(name: "Run", dependencies: ["App"]),
        .testTarget(name: "AppTests", dependencies: [
            .target(name: "App"),
            .product(name: "XCTVapor", package: "vapor"),
        ])
    ]
)
</code></pre><p>Open the project by double clicking the <code>Package.swift</code> file. Xcode will download all the required package dependencies first, then you‚Äôll be ready to run your app (you might have to select the Run target & the proper device) and write some server side Swift code.</p><h2>Getting started with Leaf 4</h2><blockquote><p>Leaf is a powerful templating language with Swift-inspired syntax. You can use it to generate dynamic HTML pages for a front-end website or generate rich emails to send from an API.</p></blockquote><p>If you choose a domain-specific language (DSL) for writing type-safe HTML (such as <a href="https://github.com/johnsundell/plot" target="_blank">Plot</a>) you‚Äôll have to rebuild your entire backend application if you want to change your templates. Leaf is a dynamic template engine, this means that you can change templates on the fly without recompiling your Swift codebase. Let me show you how to setup Leaf.</p><pre><code class="language-swift">import Vapor
import Leaf

public func configure(_ app: Application) throws {

    app.middleware.use(FileMiddleware(publicDirectory: app.directory.publicDirectory))

    if !app.environment.isRelease {
        LeafRenderer.Option.caching = .bypass
    }

    app.views.use(.leaf)

    try routes(app)
}
</code></pre><p>With just a few lines of code you are ready to use Leaf. If you build & run your app you‚Äôll be able to modify your templates and see the changes instantly if reload your browser, that‚Äôs because we‚Äôve bypassed the cache mechanism using the <code>LeafRenderer.Option.caching</code> property. If you build your backend application in release mode the Leaf cache will be enabled, so you need to restart your server after you edit a template.</p><p>Your templates should have a <code>.leaf</code> extension and they should be placed under the <code>Resources/Views</code> folder inside your working directory by default. You can change this behavior through the <code>LeafEngine.rootDirectory</code> configuration and you can also alter the default file extension with the help of the <code>NIOLeafFiles</code> source object.</p><pre><code class="language-swift">import Vapor
import Leaf
    
public func configure(_ app: Application) throws {

    app.middleware.use(FileMiddleware(publicDirectory: app.directory.publicDirectory))

    if !app.environment.isRelease {
        LeafRenderer.Option.caching = .bypass
    }
    
    let detected = LeafEngine.rootDirectory ?? app.directory.viewsDirectory
    LeafEngine.rootDirectory = detected

    LeafEngine.sources = .singleSource(NIOLeafFiles(fileio: app.fileio,
                                                    limits: .default,
                                                    sandboxDirectory: detected,
                                                    viewDirectory: detected,
                                                    defaultExtension: "html"))
    
    app.views.use(.leaf)

    try routes(app)

}
</code></pre><p>The LeafEngine uses sources to look up template locations when you call your render function with a given template name. You can also use multiple locations or build your own lookup source if you implement the <code>LeafSource</code> protocol if needed.</p><pre><code class="language-swift">import Vapor
import Leaf
    
public func configure(_ app: Application) throws {

    app.middleware.use(FileMiddleware(publicDirectory: app.directory.publicDirectory))

    if !app.environment.isRelease {
        LeafRenderer.Option.caching = .bypass
    }
    
    let detected = LeafEngine.rootDirectory ?? app.directory.viewsDirectory
    LeafEngine.rootDirectory = detected

    let defaultSource = NIOLeafFiles(fileio: app.fileio,
                                     limits: .default,
                                     sandboxDirectory: detected,
                                     viewDirectory: detected,
                                     defaultExtension: "leaf")

    let customSource = CustomSource()

    let multipleSources = LeafSources()
    try multipleSources.register(using: defaultSource)
    try multipleSources.register(source: "custom-source-key", using: customSource)

    LeafEngine.sources = multipleSources
    
    app.views.use(.leaf)

    try routes(app)
}

struct CustomSource: LeafSource {

    func file(template: String, escape: Bool, on eventLoop: EventLoop) -> EventLoopFuture<ByteBuffer> {
        /// Your custom lookup method comes here...
        return eventLoop.future(error: LeafError(.noTemplateExists(template)))
    }
}
</code></pre><p>Anyway, this is a more advanced topic, we‚Äôre good to go with a single source, also I highly recommend using a <code>.html</code> extension instead of leaf, so Xcode can give us partial syntax highlight for our Leaf files. Now we are going to make our very first Leaf template file. üçÉ</p><blockquote><p>NOTE: You can enable basic syntax highlighting for .leaf files in Xcode by choosing the Editor ‚ñ∏ Syntax Coloring ‚ñ∏ HTML menu item. Unfortunately if you close Xcode you have to do this again and again for every single Leaf file.</p></blockquote><p>Create a new file under the <code>Resources/Views</code> directory called <code>index.html</code>.</p><pre><code class="language-html"><!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>#(title)</title>
  </head>
  <body>
    <h1>#(body)</h1>
  </body>
</html>
</code></pre><p>Leaf gives you the ability to put specific building blocks into your HTML code. These blocks (or tags) are always starting with the <code>#</code> symbol. You can think of these as preprocessor macros (if you are familiar with those). The Leaf renderer will process the template file and print the <code>#()</code> placeholders with actual values. In this case both the body and the title key is a placeholder for a context variable. We‚Äôre going to set these up using Swift. üòâ</p><p>After the template file has been processed it‚Äôll be rendered as a HTML output string. Let me show you how this works in practice. First we need to respond some HTTP request, we can use a router to register a handler function, then we tell our template engine to render a template file, we send this rendered HTML string with the appropriate <code>Content-Type</code> HTTP header value as a response, all of this happens under the hood automatically, we just need to write a few lines of Swift code.</p><pre><code class="language-swift">import Vapor
import Leaf

func routes(_ app: Application) throws {

    app.get { req in
        req.leaf.render(template: "index", context: [
            "title": "Hi",
            "body": "Hello world!"
        ])
    }
}
</code></pre><p>The snippet above goes to your routes.swift file. Routing is all about responding to HTTP requests. In this example using the .get you can respond to the / path. In other words if you run the app and enter <code>http://localhost:8080</code> into your browser, you should be able to see the rendered view as a response.</p><p>The first parameter of the render method is the name of the template file (without the file extension). As a second parameter you can pass anything that can represent a context variable. This is usually in a key-value format, and you can use almost every native Swift type including arrays and dictionaries. ü§ì</p><p>When you run the app using Xcode, don‚Äôt forget to set a custom working directory, otherwise Leaf won‚Äôt find your templates. You can also run the server using the command line: <code>swift run Run</code>.</p><p><img src="xcode-custom-working-directory.png" alt="Xcode custom working directory"></p><p>Congratulations! You just made your very first webpage. üéâ</p><h2>Inlining, evaluation and block definitions</h2><p>Leaf is a lightweight, but very powerful template engine. If you learn the basic principles, you‚Äôll be able to completely separate the view layer from the business logic. If you are familiar with HTML, you‚Äôll find that Leaf is easy to learn & use. I‚Äôll show you some handy tips real quick.</p><p>Splitting up templates is going to be essential if you are planning to build a multi-page website. You can create reusable leaf templates as components that you can inline later on.</p><p>We are going to update our index template and give an opportunity for other templates to set a custom title & description variable and define a bodyBlock that we can evaluate (or call) inside the index template. Don‚Äôt worry, you‚Äôll understand this entire thing when you look at the final code.</p><pre><code class="language-html"><!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>#(title)</title>
    <meta name="description" content="#(description)">
  </head>
  <body>
    <main>
        #bodyBlock()
    </main>
  </body>
</html>
</code></pre><p>The example above is a really good starting point. We could render the index template and pass the <code>title</code> & <code>description</code> properties using Swift, of course the <code>bodyBlock</code> would be still missing, but let me show you how can we define that using a different Leaf file called <code>home.html</code>.</p><pre><code class="language-html">#let(description = "This is the description of our home page.")
#define(bodyBlock):
<section class="wrapper">
    <h2>#(header)</h2>
</section>
<section class="wrapper">
    <p>#(message)</p>
</section>
#enddefine
#inline("index")
</code></pre><p>Our home template starts with a constant declaration using the <code>#let</code> syntax (you can also use <code>#var</code> to define variables), then in the next line we build a new reusable block with a multi-line content. Inside the body we can also print out variables combined with HTML code, every single context variable is also available inside definition blocks. In the very last line we tell the system that it should inline the contents of our index template. This means that we‚Äôre literally copy & paste the contents of that file here. Think of it like this:</p><pre><code class="language-html">#let(description = "This is the description of our home page.")
#define(bodyBlock):
<section class="wrapper">
    <h2>#(header)</h2>
</section>
<section class="wrapper">
    <p>#(message)</p>
</section>
#enddefine
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>#(title)</title>
    <meta name="description" content="#(description)">
  </head>
  <body>
    <main>
        #bodyBlock()
    </main>
  </body>
</html>
</code></pre><p>As you can see we still need values for the title, header and message variables. We don‚Äôt have to deal with the bodyBlock anymore, the renderer will evaluate that block and simply replace the contents of the block with the defined body, this is how you can imagine the template before the variable replacement:</p><pre><code class="language-html">#let(description = "This is the description of our home page.")
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>#(title)</title>
    <meta name="description" content="#(description)">
  </head>
  <body>
    <main>
        <section class="wrapper">
            <h2>#(header)</h2>
        </section>
        <section class="wrapper">
            <p>#(message)</p>
        </section>
    </main>
  </body>
</html>
</code></pre><p>Now that‚Äôs not the most accurate representation of how the LeafRenderer works, but I hope that it‚Äôll help you to understand this whole define / evaluate syntax thing.</p><blockquote><p>NOTE: You can also use the <code>#evaluate</code> tag instead of calling the block (<code>bodyBlock()</code> vs <code>#evaluate(bodyBlock)</code>, these two snippets are essentially the same).</p></blockquote><p>It‚Äôs time to render the <code>page</code> template. Again, we don‚Äôt have to deal with the bodyBlock, since it‚Äôs already defined in the home template, the description value also exists, because we created a new constant using the #let tag. We only have to pass around the <code>title</code>, <code>header</code> and <code>message</code> keys with proper values as context variables for the renderer.</p><pre><code class="language-swift">app.get { req in
    req.leaf.render(template: "home", context: [
        "title": "My Page",
        "header": "This is my own page.",
        "message": "Welcome to my page!"
    ])
}
</code></pre><p>It‚Äôs possible to inline multiple Leaf files, so for example you can create a hierarchy of templates such as: <code>index ‚ñ∏ page ‚ñ∏ welcome</code>, just follow the same pattern that I introduced above. Worth to mention that you can inline files as raw files (<code>#inline("my-file", as: raw)</code>), but this way they won‚Äôt be processed during rendering. üòä</p><h2>LeafData, loops and conditions</h2><p>Passing some custom data to the view is not that hard, you just have to conform to the <code>LeafDataRepresentable</code> protocol. Let‚Äôs build a new <code>list.html</code> template first, so I can show you a few other practical things as well.</p><pre><code class="language-html">#let(title = "My custom list")
#let(description = "This is the description of our list page.")
#var(heading = nil)
#define(bodyBlock):
<h1>#(heading ?? "Todo list")</h1>
<ul>
#for(todo in todos):
    <li>#if(todo.isCompleted):‚úÖ#else:‚ùå#endif #(todo.name)</p></li>
#endfor
</ul>
#enddefine
#inline("index")
</code></pre><p>We declare two constants so we don‚Äôt have to pass around the title and description using the same keys as context variables. Next we use the variable syntax to override our heading and set it to a nil value, we‚Äôre doing this so I can show you that we can use the coalescing (<code>??</code>) operator to chain optional values. Next we use the #for block to iterate through our list. The todos variable will be a context variable that we setup using Swift later on. We can also use conditions to check values or expressions, the syntax is pretty much straightforward.</p><p>Now we just have to create a data structure to represent our Todo items.</p><pre><code class="language-swift">import Vapor
import Leaf

struct Todo {
    let name: String
    let isCompleted: Bool
}

extension Todo: LeafDataRepresentable {

    var leafData: LeafData {
        .dictionary([
            "name": name,
            "isCompleted": isCompleted,
        ])
    }
}
</code></pre><p>I made a new <code>Todo</code> struct and extended it so it can be used as a LeafData value during the template rendering process. You can extend Fluent models just like this, usually you will have to return a LeafData.dictionary type with your object properties as specific values under given keys. You can extend the dictionary with computed properties, but this is a great way to hide sensitive data from the views. Just completely ignore the password fields. üòÖ</p><p>Time to render a list of todos, this is one possible approach:</p><pre><code class="language-swift">func routes(_ app: Application) throws {

    app.get { req -> EventLoopFuture<View> in
        let todos = [
            Todo(name: "Update Leaf 4 articles", isCompleted: true),
            Todo(name: "Write a brand new article", isCompleted: false),
            Todo(name: "Fix a bug", isCompleted: true),
            Todo(name: "Have fun", isCompleted: true),
            Todo(name: "Sleep more", isCompleted: false),
        ]
        return req.leaf.render(template: "list", context: [
            "heading": "Lorem ipsum",
            "todos": .array(todos),
        ])
    }
}
</code></pre><p>The only difference is that we have to be more explicit about types. This means that we have to tell the Swift compiler that the request handler function returns a generic EventLoopFuture object with an associated View type. The Leaf renderer works asynchronously so that‚Äôs why we have to work with a future value here. If you don‚Äôt how how they work, please read about them, futures and promises are quite essential building blocks in Vapor.</p><p>The very last thing I want to talk about is the context argument. We return a <code>[String: LeafData]</code> type, that‚Äôs why we have to put an additional <code>.array</code> initializer around the todos variable so the renderer will know the exact type here. Now if you run the app you should be able to see our todos.</p><h2>Summary</h2><p>I hope that this tutorial will help you to build better templates using Leaf. If you understand the basic building blocks, such as inlines, definitions and evaluations, it‚Äôs going to be really easy to compose your template hierarchies. If you want to learn more about Leaf or Vapor you should check for more tutorials in the articles section or you can purchase my <a href="https://gumroad.com/l/practical-server-side-swift/" target="_blank">Practical Server Side Swift book</a>.</p>
        
    </section>
    
    <h2>Next</h2>
    
    <h2>Prev</h2>
        <div class="post card">
            <a href="/posts/hummingbird-routing-and-requests/" target="">
                <figure>
                    <picture>
                        <img
                            src=""
                            alt=""
                            title=""
                        >
                    </picture>
                </figure>
                <section>
                    <time datetime="2023-03-17 16:20:00">2023-03-17 16:20:00</time>
                    <h2 class="title">Hummingbird routing and requests</h2>
                </section>
                <p>Beginner&#39;s guide to learn all about routing and request handling using the Hummingbird server-side Swift framework.</p>
            </a>
        
            
            
        
        </div>
    
    <h2>Related</h2>
    Empty.
    
    <h2>More by author(s)</h2>
    Empty.

</article>

    </main>

    <footer id="page-footer">
        <section class="content-wrapper">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
    
            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p>
                <a href="https://binarybirds.com/">Home</a> ¬∑
                <a href="mailto:binarybirdsofficial@gmail.com">Email</a> ¬∑
                <a href="https://github.com/binarybirds/">GitHub</a> ¬∑
                <a href="https://x.com/tiborbodecs">Twitter</a> ¬∑
                <a href="/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="/sitemap.xml" target="_blank">Sitemap</a>
            </p>
    
            <p class="small"> &copy; 2022 - 2024.</p>
        </section>
    </footer>
</body>
</html>
