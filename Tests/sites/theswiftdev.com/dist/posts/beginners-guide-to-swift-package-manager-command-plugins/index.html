<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Beginner&#39;s guide to Swift package manager command plugins - </title>
    <meta name="description" content="Learn how to create command plugins for the Swift Package Manager to execute custom actions using SPM and other tools.">
    
    <meta property="og:url" content="/posts/beginners-guide-to-swift-package-manager-command-plugins/">
    <meta property="og:title" content="Beginner&#39;s guide to Swift package manager command plugins - ">
    <meta property="og:description" content="Learn how to create command plugins for the Swift Package Manager to execute custom actions using SPM and other tools.">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Beginner&#39;s guide to Swift package manager command plugins - ">
    <meta name="twitter:description" content="Learn how to create command plugins for the Swift Package Manager to execute custom actions using SPM and other tools.">
    
    <link rel="stylesheet" href="/css/global.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">

    <link rel="shortcut icon" href="/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-touch-icon-180x180.png">

</head>

<body>
    <header id="navigation">
        <a id="site-logo" href="">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
        </a>
    
        <nav id="primary-menu">
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/">Home</a>
                <a href="/blog/">Blog</a>
                <a href="/posts/pages/1/">Posts</a>
                <a href="/authors/">Authors</a>
                <a href="/tags/">Tags</a>
                <a href="/my-page/">My page</a>
            </div>
        </nav>
    
        <nav id="secondary-menu">
            <input type="checkbox" id="secondary-menu-button" name="menu-button" class="menu-button">
            <label for="secondary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="1"></circle>
                    <circle cx="12" cy="5" r="1"></circle>
                    <circle cx="12" cy="19" r="1"></circle>
                </svg>
            </label>
            <div class="menu-items right">
                <a href="#">My account</a>
                <a href="/">Logout</a>
            </div>
        </nav>
    </header>
        
    <main>

<article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2022-05-16 16:20:00">2022-05-16 16:20:00</time>
            <h1 class="title">Beginner&#39;s guide to Swift package manager command plugins</h1>
            <p class="excerpt">Learn how to create command plugins for the Swift Package Manager to execute custom actions using SPM and other tools.</p>
        </section>
        
    </header>

    <section id="contents" class="content-wrapper">
    
    <h2>Introduction to Swift Package Manager plugins</h2><p>First of all I‚Äôd like to talk a few words about the new SPM plugin infrastructure, that was introduced in the Swift 5.6 release. The very <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0303-swiftpm-extensible-build-tools.md" target="_blank">first proposal</a> describes the detailed design of the plugin API with some <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0303-swiftpm-extensible-build-tools.md#example-1-swiftgen" target="_blank">plugin examples</a>, which are quite handy. Honestly speaking I was a bit to lazy to carefully read through the entire documentation, it‚Äôs quite long, but long story short, you can create the following plugin types with the currently existing APIs:</p><ul><li>Build tools - can be invoked via the SPM targets<ul><li>pre-build - runs before the build starts</li><li>build - runs during the build</li></ul></li><li>Commands - can be invoked via the command line<ul><li>source code formatting - modifies the code inside package</li><li>documentation generation - generate docs for the package</li><li>custom - user defined intentions</li></ul></li></ul><p>For the sake of simplicity in this tutorial I‚Äôm only going to write a bit about the second category, aka. the command plugins. These plugins were a bit more interesting for me, because I wanted to integrate my deployment workflow into SPM, so I started to experiment with the plugin API to see how hard it is to build such a thing. Turns out it‚Äôs quite easy, but the developer experience it‚Äôs not that good. üòÖ</p><h2>Building a source code formatting plugin</h2><p>The very first thing I wanted to integrate with SPM was <a href="https://github.com/realm/SwiftLint" target="_blank">SwiftLint</a>, since I was not able to find a plugin implementation that I could use I started from scratch. As a starting point I was using the <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0332-swiftpm-command-plugins.md#example-2-formatting-source-code" target="_blank">example code</a> from the <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0332-swiftpm-command-plugins.md" target="_blank">Package Manager Command Plugins proposal</a>.</p><pre><code>mkdir Example
cd Example
swift package init --type=library
</code></pre><p>I started with a brand new package, using the swift package init command, then I modified the Package.swift file according to the documentation. I‚Äôve also added <a href="https://github.com/realm/SwiftLint" target="_blank">SwiftLint</a> as a package dependency so SPM can download & build the and hopefully my custom plugin command can invoke the swiftlint executable when it is needed.</p><pre><code class="language-swift">// swift-tools-version: 5.6
import PackageDescription

let package = Package(
    name: "Example",
    platforms: [
        .macOS(.v10_15),
    ],
    products: [
        .library(name: "Example", targets: ["Example"]),
        .plugin(name: "MyCommandPlugin", targets: ["MyCommandPlugin"]),
    ],
    dependencies: [
        .package(url: "https://github.com/realm/SwiftLint", branch: "master"),
    ],
    targets: [
        .target(name: "Example", dependencies: []),
        .testTarget(name: "ExampleTests", dependencies: ["Example"]),
       
        .plugin(name: "MyCommandPlugin",
                capability: .command(
                    intent: .sourceCodeFormatting(),
                    permissions: [
                        .writeToPackageDirectory(reason: "This command reformats source files")
                    ]
                ),
                dependencies: [
                    .product(name: "swiftlint", package: "SwiftLint"),
                ]),
    ]
)
</code></pre><p>I‚Äôve created a <code>Plugins</code> directory with a <code>main.swift</code> file right next to the Sources folder, with the following contents.</p><pre><code class="language-swift">import PackagePlugin
import Foundation

@main
struct MyCommandPlugin: CommandPlugin {
    
    func performCommand(context: PluginContext, arguments: [String]) throws {
        let tool = try context.tool(named: "swiftlint")
        let toolUrl = URL(fileURLWithPath: tool.path.string)
        
        for target in context.package.targets {
            guard let target = target as? SourceModuleTarget else { continue }

            let process = Process()
            process.executableURL = toolUrl
            process.arguments = [
                "\(target.directory)",
                "--fix",
               // "--in-process-sourcekit" // this line will fix the issues...
            ]

            try process.run()
            process.waitUntilExit()
            
            if process.terminationReason == .exit && process.terminationStatus == 0 {
                print("Formatted the source code in \(target.directory).")
            }
            else {
                let problem = "\(process.terminationReason):\(process.terminationStatus)"
                Diagnostics.error("swift-format invocation failed: \(problem)")
            }
        }
    }
}
</code></pre><p>The snippet above should locate the swiftlint tool using the plugins context then it‚Äôll iterate through the available package targets, filter out non source-module targets and format only those targets that contains actual Swift source files. The process object should simply invoke the underlying tool, we can wait until the child (swiftlint invocation) process exists and hopefully we‚Äôre good to go. ü§û</p><blockquote><p>NOTE: Update: <a href="https://x.com/k_alweheshy" target="_blank">kalKarmaDev</a> told me that it is possible to pass the <code>--in-process-sourcekit</code> argument to SwiftLint, this will fix the underlying issue and the source files are actually fixed.</p></blockquote><p>I wanted to list the available plugins & run my source code linter / formatter using the following shell commands, but unfortunately seems like the swiftlint invocation part failed for some strange reason.</p><pre><code class="language-sh">swift package plugin --list
swift package format-source-code #won't work, needs access to source files
swift package --allow-writing-to-package-directory format-source-code

# error: swift-format invocation failed: NSTaskTerminationReason(rawValue: 2):5
# what the hell happened? ü§î
</code></pre><p>Seems like there‚Äôs a problem with the exit code of the invoked swiftlint process, so I removed the success check from the plugin source to see if that‚Äôs causing the issue or not also tried to print out the executable command to debug the underlying problem.</p><pre><code class="language-swift">import PackagePlugin
import Foundation

@main
struct MyCommandPlugin: CommandPlugin {
    
    func performCommand(context: PluginContext, arguments: [String]) throws {
        let tool = try context.tool(named: "swiftlint")
        let toolUrl = URL(fileURLWithPath: tool.path.string)
        
        for target in context.package.targets {
            guard let target = target as? SourceModuleTarget else { continue }

            let process = Process()
            process.executableURL = toolUrl
            process.arguments = [
                "\(target.directory)",
                "--fix",
            ]

            print(toolUrl.path, process.arguments!.joined(separator: " "))

            try process.run()
            process.waitUntilExit()
        }
    }
}
</code></pre><p>Intentionally made a small ‚Äúmistake‚Äù in the Example.swift source file, so I can see if the swiftlint ‚Äìfix command will solve this issue or not. ü§î</p><pre><code class="language-swift">public struct Example {
    public private(set) var text = "Hello, World!"

    public init() {
        let xxx :Int = 123
    }
}
</code></pre><p>Turns out, when I run the plugin via the <a href="https://developer.apple.com/documentation/foundation/process" target="_blank">Process</a> invocation, nothing happens, but when I enter the following code manually into the shell, it just works.</p><pre><code class="language-sh">/Users/tib/Example/.build/arm64-apple-macosx/debug/swiftlint /Users/tib/Example/Tests/Example --fix
/Users/tib/Example/.build/arm64-apple-macosx/debug/swiftlint /Users/tib/Example/Tests/ExampleTests --fix
</code></pre><p>All right, so we definitely have a problem here‚Ä¶ I tried to get the standard output message and error message from the running process, seems like swiftlint runs, but something in the SPM infrastructure blocks the code changes in the package. After several hours of debugging I decided to give a shot to <a href="https://github.com/apple/swift-format" target="_blank">swift-format</a>, because that‚Äôs what the official docs suggest. ü§∑‚Äç‚ôÇÔ∏è</p><pre><code class="language-swift">// swift-tools-version: 5.6
import PackageDescription

let package = Package(
    name: "Example",
    platforms: [
        .macOS(.v10_15),
    ],
    products: [
        .library(name: "Example", targets: ["Example"]),
        .plugin(name: "MyCommandPlugin", targets: ["MyCommandPlugin"]),
    ],
    dependencies: [
        .package(url: "https://github.com/apple/swift-format", exact: "0.50600.1"),
    ],
    targets: [
        .target(name: "Example", dependencies: []),
        .testTarget(name: "ExampleTests", dependencies: ["Example"]),
       
        .plugin(name: "MyCommandPlugin",
                capability: .command(
                    intent: .sourceCodeFormatting(),
                    permissions: [
                        .writeToPackageDirectory(reason: "This command reformats source files")
                    ]
                ),
                dependencies: [
                    .product(name: "swift-format", package: "swift-format"),
                ]),
    ]
)
</code></pre><p>Changed both the <code>Package.swift</code> file and the plugin source code, to make it work with swift-format.</p><pre><code class="language-swift">import PackagePlugin
import Foundation

@main
struct MyCommandPlugin: CommandPlugin {
    
    func performCommand(context: PluginContext, arguments: [String]) throws {
        let swiftFormatTool = try context.tool(named: "swift-format")
        let swiftFormatExec = URL(fileURLWithPath: swiftFormatTool.path.string)
//        let configFile = context.package.directory.appending(".swift-format.json")
        
        for target in context.package.targets {
            guard let target = target as? SourceModuleTarget else { continue }

            let process = Process()
            process.executableURL = swiftFormatExec
            process.arguments = [
//                "--configuration", "\(configFile)",
                "--in-place",
                "--recursive",
                "\(target.directory)",
            ]
            try process.run()
            process.waitUntilExit()

            if process.terminationReason == .exit && process.terminationStatus == 0 {
                print("Formatted the source code in \(target.directory).")
            }
            else {
                let problem = "\(process.terminationReason):\(process.terminationStatus)"
                Diagnostics.error("swift-format invocation failed: \(problem)")
            }
        }
    }
}
</code></pre><p>I tried to run again the exact same package plugin command to format my source files, but this time swift-format was doing the code formatting instead of swiftlint.</p><pre><code class="language-sh">swift package --allow-writing-to-package-directory format-source-code
// ... loading dependencies
Build complete! (6.38s)
Formatted the source code in /Users/tib/Linter/Tests/ExampleTests.
Formatted the source code in /Users/tib/Linter/Sources/Example.
</code></pre><p>Worked like a charm, my Example.swift file was fixed and the : was on the left side‚Ä¶ üéä</p><pre><code class="language-swift">public struct Example {
    public private(set) var text = "Hello, World!"

    public init() {
        let xxx: Int = 123
    }
}
</code></pre><p>Yeah, I‚Äôve made some progress, but it took me quite a lot of time to debug this issue and I don‚Äôt like the fact that I have to mess around with processes to invoke other tools‚Ä¶ my gut tells me that SwiftLint is not following the standard shell exit status codes and that‚Äôs causing some issues, maybe it‚Äôs spawning child processes and that‚Äôs the problem, I really don‚Äôt know but I don‚Äôt wanted to waste more time on this issue, but I wanted to move forward with the other category. üòÖ</p><h2>Integrating the DocC plugin with SPM</h2><p>As a first step I added some dummy comments to my Example library to be able to see something in the generated documentation, nothing fancy just some one-liners. üìñ</p><pre><code class="language-swift">/// This is just an example struct
public struct Example {

    /// this is the hello world text
    public private(set) var text = "Hello, World!"
    
    /// this is the init method
    public init() {
        let xxx: Int = 123
    }
}
</code></pre><p>I discovered that Apple has an <a href="https://github.com/apple/swift-docc-plugin" target="_blank">official DocC plugin</a>, so I added it as a dependency to my project.</p><pre><code class="language-swift">// swift-tools-version: 5.6
import PackageDescription

let package = Package(
    name: "Example",
    platforms: [
        .macOS(.v10_15),
    ],
    products: [
        .library(name: "Example", targets: ["Example"]),
        .plugin(name: "MyCommandPlugin", targets: ["MyCommandPlugin"]),
    ],
    dependencies: [
        .package(url: "https://github.com/apple/swift-format", exact: "0.50600.1"),
        .package(url: "https://github.com/apple/swift-docc-plugin", from: "1.0.0"),

    ],
    targets: [
        .target(name: "Example", dependencies: []),
        .testTarget(name: "ExampleTests", dependencies: ["Example"]),
       
        .plugin(name: "MyCommandPlugin",
                capability: .command(
                    intent: .sourceCodeFormatting(),
                    permissions: [
                        .writeToPackageDirectory(reason: "This command reformats source files")
                    ]
                ),
                dependencies: [
                    .product(name: "swift-format", package: "swift-format"),
                ]),
    ]
)
</code></pre><p>Two new plugin commands were available after I executed the plugin list command.</p><pre><code class="language-sh">swift package plugin --list

# ‚Äòformat-source-code‚Äô (plugin ‚ÄòMyCommandPlugin‚Äô in package ‚ÄòExample‚Äô)
# ‚Äògenerate-documentation‚Äô (plugin ‚ÄòSwift-DocC‚Äô in package ‚ÄòSwiftDocCPlugin‚Äô)
# ‚Äòpreview-documentation‚Äô (plugin ‚ÄòSwift-DocC Preview‚Äô in package ‚ÄòSwiftDocCPlugin‚Äô)
</code></pre><p>Tried to run the first one, and fortunately the doccarchive file was generated. üòä</p><pre><code class="language-sh">swift package generate-documentation
# Generating documentation for 'Example'...
# Build complete! (0.16s)
# Converting documentation...
# Conversion complete! (0.33s)
# Generated DocC archive at '/Users/tib/Linter/.build/plugins/Swift-DocC/outputs/Example.doccarchive'
</code></pre><p>Also tried to preview the documentation, there was a note about the ‚Äìdisable-sandbox flag in the output, so I simply added it to my original command and‚Ä¶</p><pre><code class="language-sh">swift package preview-documentation 
# Note: The Swift-DocC Preview plugin requires passing the '--disable-sandbox' flag
swift package --disable-sandbox preview-documentation
</code></pre><p>Magic. It worked and my documentation was available. Now this is how plugins should work, I loved this experience and I really hope that more and more official plugins are coming soon. üòç</p><h2>Building a custom intent command plugin</h2><p>I wanted to build a small executable target with some bundled resources and see if a plugin can deploy the executable binary with the resources. This could be very useful when I deploy feather apps, I have multiple module bundles there and now I have to manually copy everything‚Ä¶ üôà</p><pre><code class="language-swift">// swift-tools-version: 5.6
import PackageDescription

let package = Package(
    name: "Example",
    platforms: [
        .macOS(.v10_15),
    ],
    products: [
        .library(name: "Example", targets: ["Example"]),
        .executable(name: "MyExample", targets: ["MyExample"]),
        .plugin(name: "MyCommandPlugin", targets: ["MyCommandPlugin"]),
        .plugin(name: "MyDistCommandPlugin", targets: ["MyDistCommandPlugin"]),
    ],
    dependencies: [
        .package(url: "https://github.com/apple/swift-format", exact: "0.50600.1"),
        .package(url: "https://github.com/apple/swift-docc-plugin", from: "1.0.0"),

    ],
    targets: [
        .executableTarget(name: "MyExample",
                          resources: [
                            .copy("Resources"),
                          ], plugins: [
                            
                          ]),
        .target(name: "Example", dependencies: []),
        .testTarget(name: "ExampleTests", dependencies: ["Example"]),
       
        .plugin(name: "MyCommandPlugin",
                capability: .command(
                    intent: .sourceCodeFormatting(),
                    permissions: [
                        .writeToPackageDirectory(reason: "This command reformats source files")
                    ]
                ),
                dependencies: [
                    .product(name: "swift-format", package: "swift-format"),
                ]),
        
        .plugin(name: "MyDistCommandPlugin",
                capability: .command(
                    intent: .custom(verb: "dist", description: "Create dist archive"),
                    permissions: [
                        .writeToPackageDirectory(reason: "This command deploys the executable")
                    ]
                ),
                dependencies: [
                ]),
    ]
)
</code></pre><p>As a first step I created a new executable target called MyExample and a new MyDistCommandPlugin with a custom verb. Inside the Sources/MyExample/Resources folder I‚Äôve placed a simple test.json file with the following contents.</p><pre><code class="language-json">{
    "success": true
}
</code></pre><p>The main.swift file of the MyExample target looks like this. It just validates that the resource file is available and it simply decodes the contents of it and prints everything to the standard output. üëç</p><pre><code class="language-swift">import Foundation

guard let jsonFile = Bundle.module.url(forResource: "Resources/test", withExtension: "json") else {
    fatalError("Bundle file not found")
}
let jsonData = try Data(contentsOf: jsonFile)

struct Json: Codable {
    let success: Bool
}

let json = try JSONDecoder().decode(Json.self, from: jsonData)

print("Is success?", json.success)
</code></pre><p>Inside the Plugins folder I‚Äôve created a main.swift file under the MyDistCommandPlugin folder.</p><pre><code class="language-swift">import PackagePlugin
import Foundation

@main
struct MyDistCommandPlugin: CommandPlugin {
    
    func performCommand(context: PluginContext, arguments: [String]) throws {
        
        // ...
    }
}
</code></pre><p>Now I was able to re-run the swift package plugin ‚Äìlist command and the dist verb appeared in the list of available commands. Now the only question is: how do we get the artifacts out of the build directory? Fortunately the <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0332-swiftpm-command-plugins.md#example-3-building-deployment-artifacts" target="_blank">3rd example</a> of the commands proposal is quite similar.</p><pre><code class="language-swift">import PackagePlugin
import Foundation

@main
struct MyDistCommandPlugin: CommandPlugin {
    
    func performCommand(context: PluginContext, arguments: [String]) throws {
        let cpTool = try context.tool(named: "cp")
        let cpToolURL = URL(fileURLWithPath: cpTool.path.string)

        let result = try packageManager.build(.product("MyExample"), parameters: .init(configuration: .release, logging: .concise))
        guard result.succeeded else {
            fatalError("couldn't build product")
        }
        guard let executable = result.builtArtifacts.first(where : { $0.kind == .executable }) else {
            fatalError("couldn't find executable")
        }
        
        let process = try Process.run(cpToolURL, arguments: [
            executable.path.string,
            context.package.directory.string,
        ])
        process.waitUntilExit()

        let exeUrl = URL(fileURLWithPath: executable.path.string).deletingLastPathComponent()
        let bundles = try FileManager.default.contentsOfDirectory(atPath: exeUrl.path).filter { $0.hasSuffix(".bundle") }

        for bundle in bundles {
            let process = try Process.run(cpToolURL, arguments: ["-R",
                                                                    exeUrl.appendingPathComponent(bundle).path,
                                                                    context.package.directory.string,
                                                                ])
            process.waitUntilExit()
        }
    }
}
</code></pre><p>So the only problem was that I was not able to get back the bundled resources, so I had to use the URL of the executable file, drop the last path component and read the contents of that directory using the FileManager to get back the .bundle packages inside of that folder.</p><p>Unfortunately the builtArtifacts property only returns the executables and libraries. I really hope that we‚Äôre going to get support for bundles as well in the future so this hacky solution can be avoided for good. Anyway it works just fine, but still it‚Äôs a hack, so use it carefully. ‚ö†Ô∏è</p><pre><code class="language-sh">swift package --allow-writing-to-package-directory dist
./MyExample 
#Is success? true
</code></pre><p>I was able to run my custom dist command without further issues, of course you can use additional arguments to customize your plugin or add more flexibility, the examples in the proposal are pretty much okay, but it‚Äôs quite unfortunate that there is no official documentation for Swift package manager plugins just yet. üòï</p><h2>Conclusion</h2><p>Learning about command plugins was fun, but in the beginning it was annoying because I expected a bit better developer experience regarding the tool invocation APIs. In summary I can say that this is just the beginning. It‚Äôs just like the async / await and actors addition to the Swift language. The feature itself is there, it‚Äôs mostly ready to go, but not many developers are using it on a daily basis. These things will require time and hopefully we‚Äôre going to see a lot more plugins later on‚Ä¶ üí™</p>
        
    </section>
    
    <h2>Next</h2>
    
    <h2>Prev</h2>
        <div class="post card">
            <a href="/posts/hummingbird-routing-and-requests/" target="">
                <figure>
                    <picture>
                        <img
                            src=""
                            alt=""
                            title=""
                        >
                    </picture>
                </figure>
                <section>
                    <time datetime="2023-03-17 16:20:00">2023-03-17 16:20:00</time>
                    <h2 class="title">Hummingbird routing and requests</h2>
                </section>
                <p>Beginner&#39;s guide to learn all about routing and request handling using the Hummingbird server-side Swift framework.</p>
            </a>
        
            
            
        
        </div>
    
    <h2>Related</h2>
    Empty.
    
    <h2>More by author(s)</h2>
    Empty.

</article>

    </main>

    <footer id="page-footer">
        <section class="content-wrapper">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
    
            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p>
                <a href="https://binarybirds.com/">Home</a> ¬∑
                <a href="mailto:binarybirdsofficial@gmail.com">Email</a> ¬∑
                <a href="https://github.com/binarybirds/">GitHub</a> ¬∑
                <a href="https://x.com/tiborbodecs">Twitter</a> ¬∑
                <a href="/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="/sitemap.xml" target="_blank">Sitemap</a>
            </p>
    
            <p class="small"> &copy; 2022 - 2024.</p>
        </section>
    </footer>
</body>
</html>
