<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Custom views, input forms and mistakes - </title>
    <meta name="description" content="Just a little advice about creating custom view programmatically and the truth about why form building with collection views sucks.">
    
    <meta property="og:url" content="/posts/custom-views-input-forms-and-mistakes/">
    <meta property="og:title" content="Custom views, input forms and mistakes - ">
    <meta property="og:description" content="Just a little advice about creating custom view programmatically and the truth about why form building with collection views sucks.">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Custom views, input forms and mistakes - ">
    <meta name="twitter:description" content="Just a little advice about creating custom view programmatically and the truth about why form building with collection views sucks.">
    
    <link rel="stylesheet" href="/css/global.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">

    <link rel="shortcut icon" href="/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-touch-icon-180x180.png">

</head>

<body>
    <header id="navigation">
        <a id="site-logo" href="">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
        </a>
    
        <nav id="primary-menu">
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/">Home</a>
                <a href="/blog/">Blog</a>
                <a href="/posts/pages/1/">Posts</a>
                <a href="/authors/">Authors</a>
                <a href="/tags/">Tags</a>
                <a href="/my-page/">My page</a>
            </div>
        </nav>
    
        <nav id="secondary-menu">
            <input type="checkbox" id="secondary-menu-button" name="menu-button" class="menu-button">
            <label for="secondary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="1"></circle>
                    <circle cx="12" cy="5" r="1"></circle>
                    <circle cx="12" cy="19" r="1"></circle>
                </svg>
            </label>
            <div class="menu-items right">
                <a href="#">My account</a>
                <a href="/">Logout</a>
            </div>
        </nav>
    </header>
        
    <main>

<article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2019-10-21 16:20:00">2019-10-21 16:20:00</time>
            <h1 class="title">Custom views, input forms and mistakes</h1>
            <p class="excerpt">Just a little advice about creating custom view programmatically and the truth about why form building with collection views sucks.</p>
        </section>
        
    </header>

    <section id="contents" class="content-wrapper">
    
    <h2>How NOT to build forms for iOS apps?</h2><p>Let‚Äôs start with an honest statement: I messed up with this tutorial (a lot):</p><p><a href="https://theswiftdev.com/2019/05/23/building-input-forms-for-ios-apps/" target="_blank">Building input forms for iOS apps</a></p><p>The thing is that this form building methodology only works if the cells are always visible on screen, which is quite a rare case. I discovered this issue while I was working on my current project and some fields were constantly disappearing and moving the cursor to the next input field stopped working when the cell was out of frame.</p><blockquote><p>Reusability & memory efficiency is not always what you want.</p></blockquote><p>Seems like <code>UICollectionView</code> is not the best solution for making input forms, because the constant cell reusability will mess up some of the expected behavior. It‚Äôs still good for lists with ‚Äúa thousand elements‚Äù, but for an input form I would not recommend this technique anymore. Yep, my mistake, sorry about it‚Ä¶ üò¨</p><h2>Learning by making mistakes</h2><p>Long story short, I made a mistake and probably you‚Äôll also make a lot during your developer career. Does this make you a bad programmer? Not at all. We‚Äôre human, we‚Äôre constantly making smaller or bigger mistakes, but‚Ä¶</p><blockquote><p>(Remain and) turn it into strength</p></blockquote><p>Your mistakes will always stay with you, but you can learn from them a lot. The problem only starts if you keep doing the same mistakes again and again, or you don‚Äôt even realize that you‚Äôre doing something wrong. It‚Äôs really hard to take one step back and see the problem from a bigger perspective. Sometimes you simply need someone else to point out the issue for you, but negative feedback can also be painful.</p><p>Anyway, I don‚Äôt want to be too much philosophical, this is a Swift developer blog ffs.</p><h3>A few things that I learned:</h3><ul><li>my ideas are not always working, so don‚Äôt trust me 100% (haha) ü§£</li><li>it‚Äôs always better to code/work in pair with someone else</li><li>sometimes the ‚Äúpadawan‚Äù will teach the ‚Äúmaster‚Äù üòâ</li><li>a professional qa team can save you a lot of time</li><li>VIPER is my architectural ‚Äúsilver bullet‚Äù, not collection views</li><li>UICollectionView based form building is not working‚Ä¶</li><li>‚Ä¶but the collection view framework still rocks for complex interfaces</li><li>have some dedicated time for code cosmetics & refactor</li><li>use view subclasses programmatically (or SwiftUI in the future)</li></ul><p>So the last point is the most interesting one, let me explain why.</p><h2>Custom view subclasses from code only</h2><p>Creating a <a href="https://theswiftdev.com/2018/10/16/custom-uiview-subclass-from-a-xib-file/" target="_blank">UIView subclass programmatically</a> is a relatively easy task. You can load a nib file or you can do it straight from code. A few weeks ago I‚Äôve learned a new trick, that was bugging me all the time I made a new subclass in Swift:</p><blockquote><p>Why the hell do I have to implement <code>init(coder:)</code> if I‚Äôm not using IB at all?</p></blockquote><p>Also what the heck is going on with <code>init(frame:)</code>, I don‚Äôt want to deal with these two <a href="https://theswiftdev.com/2017/10/11/uikit-init-patterns/" target="_blank">init methods</a> anymore, since I‚Äôm using auto layout and I‚Äôm completely trying to ignore interface builder with the messed up storyboards and nibs as well.</p><pre><code class="language-swift">class View: UIView {

    @available(*, unavailable)
    override init(frame: CGRect) {
        super.init(frame: frame)

        self.initialize()
    }

    @available(*, unavailable)
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)

        self.initialize()
    }

    init() {
        super.init(frame: .zero)

        self.initialize()
    }

    func initialize() {
        self.translatesAutoresizingMaskIntoConstraints = false
    }
}
</code></pre><p>The solution: mark these stupid init functions as unavailable, so no-one can use them anymore. The only source of truth will be your own init method, which is quite a relief if you were so annoyed about the messed up initialization process like I was. üò§</p><p>Now you have your own base class that you can use as a parent for your future views. Of course you‚Äôll need to do the same thing for almost every UI element, like labels, buttons, text fields, etc. That‚Äôs a lot of work, but on a long term it‚Äôs totally worth it.</p><pre><code class="language-swift">import UIKit

class TitleLabel: Label {

    override func initialize() {
        super.initialize()

        self.textAlignment = .center
        self.font = UIFont.preferredFont(forTextStyle: .largeTitle)
        self.textColor = .systemBlue
    }

    func constraints(in view: UIView, padding: CGFloat = 8) -> [NSLayoutConstraint] {
        [
            self.topAnchor.constraint(equalTo: view.topAnchor, constant: padding),
            self.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: padding),
            self.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -1 * padding),
        ]
    }
}
</code></pre><p>A good practice can be to have subclass for each and every custom user interface component, like the primary button, secondary button, title label, header label, etc. This way you don‚Äôt have to configure your views in the view controller, plus you can put your frequently used constraints into the subclass using some helper methods.</p><p>Also you can have some nice extensions, those can help you with view configurations. You know, just like modifiers in SwiftUI. You can even recreate the exact same syntax. The underlying behavior won‚Äôt be the same, but that‚Äôs another story. üìö</p><h2>What about the form new builder in iOS?</h2><p>Oh, yeah almost forgot. I have a brand new, but still very similar solution. I‚Äôm using view subclasses instead of collection view components, plus the collection view have been replaced with a <code>UIScrollView</code> + <code>UIStackView</code> combination. üêê</p><pre><code class="language-swift">class ViewController: UIViewController {

    weak var scrollView: ScrollView!
    weak var stackView: VerticalStackView!

    override func loadView() {
        super.loadView()

        let scrollView = ScrollView()
        self.view.addSubview(scrollView)
        self.scrollView = scrollView
        NSLayoutConstraint.activate([/*...*/])

        let stackView = VerticalStackView()
        self.scrollView.addSubview(stackView)
        self.stackView = stackView
        NSLayoutConstraint.activate([/*...*/])
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        self.title = "StackForm"
        self.navigationController?.navigationBar.prefersLargeTitles = true

        let email = EmailTextField(id: "email-input", placeholder: "Email")
        self.stackView.addArrangedSubview(email)

        let password = PasswordTextField(id: "password-input", placeholder: "Password")
        self.stackView.addArrangedSubview(password)

        let submit = SubmitButton(id: "submit-button", title: "Submit")
        .onTouch { [weak self] _ in self?.submit() }
        self.stackView.addArrangedSubview(submit)
    }

    func submit() {
        guard
            let email = (self.view.view(withId: "email-input") as? UITextField)?.text,
            let password = (self.view.view(withId: "password-input") as? UITextField)?.text
        else {
            return
        }
        print("Account: \(email) - \(password)")
    }
}
</code></pre><p>As you can see I‚Äôm still using the same <a href="https://theswiftdev.com/2019/04/02/uniquely-identifying-views/" target="_blank">view identification technique</a>, plus I still prefer to have the SwiftUI-like <code>.onTouch</code> action handlers. You might ask though:</p><h2>Why don‚Äôt you simply go with SwiftUI?</h2><p>Well, the thing is that SwiftUI is iOS 13 only, which is only around ~55% adoption nowadays, that‚Äôs one of the main reasons, but also SwiftUI is kind of incomplete.</p><p>I‚Äôm trying to get as close as I can to SwiftUI, so the transition will be less pain in the ass when the time comes. SwiftUI will be amazing, but still it‚Äôs a giant leap forward. Sometimes I believe that Apple is rushing things just because of marketing / developer needs (yeah, we are very impatient animals). Maybe a simple wrapper framework around UIKit / AppKit without the whole declarative syntax would have been a better idea as a first step‚Ä¶ who knows‚Ä¶ CoreKit -> AppleKit? ü§î</p><p>Anyway, you can download a working example of my latest form building solution in Swift 5 from <a href="https://github.com/theswiftdev/tutorials" target="_blank">GitHub</a>. Just look for the <code>StackForm</code> folder inside the repository.</p>
        
    </section>
    
    <h2>Next</h2>
    
    <h2>Prev</h2>
        <div class="post card">
            <a href="/posts/hummingbird-routing-and-requests/" target="">
                <figure>
                    <picture>
                        <img
                            src=""
                            alt=""
                            title=""
                        >
                    </picture>
                </figure>
                <section>
                    <time datetime="2023-03-17 16:20:00">2023-03-17 16:20:00</time>
                    <h2 class="title">Hummingbird routing and requests</h2>
                </section>
                <p>Beginner&#39;s guide to learn all about routing and request handling using the Hummingbird server-side Swift framework.</p>
            </a>
        
            
            
        
        </div>
    
    <h2>Related</h2>
    Empty.
    
    <h2>More by author(s)</h2>
    Empty.

</article>

    </main>

    <footer id="page-footer">
        <section class="content-wrapper">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
    
            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p>
                <a href="https://binarybirds.com/">Home</a> ¬∑
                <a href="mailto:binarybirdsofficial@gmail.com">Email</a> ¬∑
                <a href="https://github.com/binarybirds/">GitHub</a> ¬∑
                <a href="https://x.com/tiborbodecs">Twitter</a> ¬∑
                <a href="/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="/sitemap.xml" target="_blank">Sitemap</a>
            </p>
    
            <p class="small"> &copy; 2022 - 2024.</p>
        </section>
    </footer>
</body>
</html>
