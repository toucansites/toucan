<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Beginner&#39;s guide to modern generic programming in Swift - </title>
    <meta name="description" content="Learn the very basics about protocols, existentials, opaque types and how they are related to generic programming in Swift.">
    
    <meta property="og:url" content="/posts/beginners-guide-to-modern-generic-programming-in-swift/">
    <meta property="og:title" content="Beginner&#39;s guide to modern generic programming in Swift - ">
    <meta property="og:description" content="Learn the very basics about protocols, existentials, opaque types and how they are related to generic programming in Swift.">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Beginner&#39;s guide to modern generic programming in Swift - ">
    <meta name="twitter:description" content="Learn the very basics about protocols, existentials, opaque types and how they are related to generic programming in Swift.">
    
    <link rel="stylesheet" href="/css/global.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">

    <link rel="shortcut icon" href="/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-touch-icon-180x180.png">

</head>

<body>
    <header id="navigation">
        <a id="site-logo" href="">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
        </a>
    
        <nav id="primary-menu">
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/">Home</a>
                <a href="/blog/">Blog</a>
                <a href="/posts/pages/1/">Posts</a>
                <a href="/authors/">Authors</a>
                <a href="/tags/">Tags</a>
                <a href="/my-page/">My page</a>
            </div>
        </nav>
    
        <nav id="secondary-menu">
            <input type="checkbox" id="secondary-menu-button" name="menu-button" class="menu-button">
            <label for="secondary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="1"></circle>
                    <circle cx="12" cy="5" r="1"></circle>
                    <circle cx="12" cy="19" r="1"></circle>
                </svg>
            </label>
            <div class="menu-items right">
                <a href="#">My account</a>
                <a href="/">Logout</a>
            </div>
        </nav>
    </header>
        
    <main>

<article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2022-06-28 16:20:00">2022-06-28 16:20:00</time>
            <h1 class="title">Beginner&#39;s guide to modern generic programming in Swift</h1>
            <p class="excerpt">Learn the very basics about protocols, existentials, opaque types and how they are related to generic programming in Swift.</p>
        </section>
        
    </header>

    <section id="contents" class="content-wrapper">
    
    <h2>Protocols (with associated types)</h2><p>According to the Swift language guide a <a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html" target="_blank">protocol</a> can define a blueprint of methods, properties and other requirements. It‚Äôs pretty easy to pre-define properties and methods using a protocol, the syntax is pretty straightforward, the problem starts to occur when we start to work with associated types. The very first question that we have to answer is this: what are associated types exactly?</p><p>An <a href="https://www.avanderlee.com/swift/associated-types-protocols/" target="_blank">associated type</a> is a generic placeholder for a specific type. We don‚Äôt know that type until the protocol is being adopted and the exact type is specified by the implementation.</p><pre><code class="language-swift">protocol MyProtocol {
    associatedtype MyType
    
    var myVar: MyType { get }
    
    func test()
}

extension MyProtocol {
    
    func test() {
        print("is this a test?")
    }
}
struct MyIntStruct: MyProtocol {
    typealias MyType = Int
    
    var myVar: Int { 42 }
}

struct MyStringStruct: MyProtocol {
    let myVar = "Hello, World!"
}

let foo = MyIntStruct()
print(foo.myVar)
foo.test()

let bar = MyStringStruct()
print(bar.myVar)
bar.test()
</code></pre><p>As you can see, associated MyType placeholder can have different types, when we implement the protocol. In the first case (MyIntStruct) we have explicitly told the compiler - by using a typealias - to use an Int type, and in the second case (<code>MyStringStruct</code>) the Swift compiler is smart enough to figure out the type of the myVar based on the provided String value.</p><p>Of course we can explicitly write <code>let myVar: String = "Hello, World!"</code> or use a computed property or a regular variable, it really doesn‚Äôt matter. The key takeaway is that we‚Äôve defined the type of the MyType placeholder when we implemented the protocol using the two struct. üîë</p><p>You can use an associated type to serve as a generic placeholder object so you don‚Äôt have to duplicate code if you need support for multiple different types.</p><h2>Existentials (any)</h2><p>Great, our generic protocol has a default test method implementation that we can use on both objects, now here‚Äôs the thing, I don‚Äôt really care about the type that‚Äôs going to implement my protocol, I just want to call this test function and use the protocol as a type, can I do that? Well, if you are using Swift 5.6+ the answer is yes, otherwise‚Ä¶</p><pre><code class="language-swift">// 
// ERROR:
//
// Protocol 'MyProtocol' can only be used as a generic constraint 
// because it has Self or associated type requirements
//
let myObject: MyProtocol 

// even better example, an array of different types using the same protocol
let items: [MyProtocol]
</code></pre><p>I bet that you‚Äôve seen this famous error message before. What the hell is happening here?</p><p>The answer is quite simple, the compiler can‚Äôt figure out the underlying associated type of the protocol implementations, since they can be different types (or should I say: dynamic at runtime ü§î), anyway, it‚Äôs not determined at compile time.</p><p>The latest version of the Swift programming language solves this issue by introducing <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0335-existential-any.md" target="_blank">a new any keyword</a>, which is a type-erasing helper that will box the final type into a wrapper object that can be used as an existential type. Sounds complicated? Well it is. üòÖ</p><pre><code class="language-swift">// ...

let myObject: any MyProtocol 

let items: [any MyProtocol] = [MyIntStruct(), MyStringStruct()]

for item in items {
    item.test()
}
</code></pre><p>By using the any keyword the system can create an invisible box type that points to the actual implementation, the box has the same type and we can call the shared interface functions on it.</p><ul><li>any HiddenMyProtocolBox: MyProtocol ‚Äî pointer ‚Äî> MyIntStruct</li><li>any HiddenMyProtocolBox: MyProtocol ‚Äî pointer ‚Äî> MyStringStruct</li></ul><p>This approach allows us to put different protocol implementations with Self associated type requirements into an array and call the test method on both of the objects.</p><p>If you really want to understand how these things work, I highly recommend to watch the <a href="https://developer.apple.com/videos/play/wwdc2022/110352/" target="_blank">Embrace Swift Generics</a> WWDC22 session video. The entire video is a gem. üíé</p><p>There is one more session called <a href="https://developer.apple.com/videos/play/wwdc2022/110353/" target="_blank">Design protocol interfaces in Swift</a> that you should definitely watch if you want to learn more about generics.</p><p>From Swift 5.7 the any keyword is mandatory when creating an existential type, this is a breaking change, but it is for the greater good. I really like how Apple tackled this issue and both the any and some keywords are really helpful, however <a href="https://swiftsenpai.com/swift/understanding-some-and-any/" target="_blank">understanding the differences</a> can be hard. ü§ì</p><h2>Opaque types (some)</h2><p>An <a href="https://docs.swift.org/swift-book/LanguageGuide/OpaqueTypes.html" target="_blank">opaque type</a> can hide the type information of a value. By default, the compiler can infer the underlying type, but in case of a protocol with an associated type the generic type info can‚Äôt be resolved, and this is where the some keyword and the opaque type can help.</p><p>The some keyword was introduced in Swift 5.1 and you must be familiar with it if you‚Äôve used SwiftUI before. First it was a return type feature only, but with Swift 5.7 you can now use the some keyword in function parameters as well.</p><pre><code class="language-swift">import SwiftUI

struct ContentView: View {

    // the compiler knows that the body is always a Text type
    var body: some View {
        Text("Hello, World!")
    }
}
</code></pre><p>By using the some keyword you can tell the compiler that you are going to work on a specific concrete type rather than the protocol, this way the compiler can perform additional optimizations and see the actual return type. This means that you won‚Äôt be able to assign a different type to a variable with a some ‚Äòrestriction‚Äô. üßê</p><pre><code class="language-swift">var foo: some MyProtocol = MyIntStruct()

// ERROR: Cannot assign value of type 'MyStringStruct' to type 'some MyProtocol'
foo = MyStringStruct()
</code></pre><p>Opaque types can be used to <a href="https://www.avanderlee.com/swift/some-opaque-types/" target="_blank">hide the actual type information</a>, you can find more great code examples using the linked article, but since my post focuses on the generics, I‚Äôd like to show you one specific thing related to this topic.</p><pre><code class="language-swift">func example<T: MyProtocol>(_ value: T) {}

func example<T>(_ value: T) where T: MyProtocol {}

func example(_ value: some MyProtocol) {}
</code></pre><p>Believe or not, but the 3 functions above are <a href="https://stackoverflow.com/questions/46810009/whats-the-difference-between-using-or-not-using-the-where-clause-with-generic" target="_blank">identical</a>. The first one is a generic function where the T placeholder type conforms to the MyProtocol protocol. The second one describes the exact same thing, but we‚Äôre using the where claues and this allows us to place further restrictions on the associated types if needed. e.g. <code>where T: MyProtocol, T.MyType == Int</code>. The third one uses the some keyword to hide the type allowing us to use anything as a function parameter that conforms to the protocol. This is a new feature in Swift 5.7 and it makes the generic syntax more simple. ü•≥</p><p>If you want to read more about the differences between the some and any keyword, you can read <a href="https://www.donnywals.com/whats-the-difference-between-any-and-some-in-swift-5-7/" target="_blank">this article</a> by Donny Wals, it‚Äôs really helpful.</p><h2>Primary associated types (Protocol<T>)</h2><p>To constraint opaque result types you can use the where clause, or alternatively we can ‚Äòtag‚Äô the protocol with one or more <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0346-light-weight-same-type-syntax.md" target="_blank">primary associated types</a>. This will allow us to make further constraints on the primary associated type when using some.</p><pre><code class="language-swift">protocol MyProtocol<MyType> {
    associatedtype MyType
    
    var myVar: MyType { get }
    
    func test()
}

//...

func example(_ value: some MyProtocol<Int>) {
    print("asdf")
}
</code></pre><p>If you want to learn more about primary associated types, you should read <a href="https://www.donnywals.com/what-are-primary-associated-types-in-swift-5-7/" target="_blank">Donny‚Äôs article</a> too. üí°</p><h2>Generics (<T>)</h2><p>So far we haven‚Äôt really talked about the standard generic features of Swift, but we were mostly focusing on protocols, associated types, existentials and opaque types. Fortunately you write <a href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html" target="_blank">generic code in Swift</a> without the need to involve all of these stuff.</p><pre><code class="language-swift">struct Bag<T> {
    var items: [T]
}

let bagOfInt = Bag<Int>(items: [4, 2, 0])
print(bagOfInt.items)

let bagOfString = Bag<String>(items: ["a", "b", "c"])
print(bagOfString.items)
</code></pre><p>This bag type has a placeholder type called T, which can hold any kind of the same type, when we initialize the bag we explicitly tell which type are we going to use. In this example we‚Äôve created a generic type using a struct, but you can also use an enum, a class or even an actor, plus it is also possible to write even more simple generic functions. üßê</p><pre><code class="language-swift">func myPrint<T>(_ value: T) {
    print(value)
}

myPrint("hello")
myPrint(69)
</code></pre><p>If you want to learn more about generics you should read <a href="https://www.hackingwithswift.com/plus/intermediate-swift/understanding-generics-part-1" target="_blank">this article</a> by Paul Hudson, it‚Äôs a nice introduction to generic programming in Swift. Since this article is more about providing an introduction I don‚Äôt want to get into the more advanced stuff. Generics can be really difficult to understand, especially if we involve protocols and the new keywords.</p><p>I hope this article will help you to understand these things just a bit better.</p>
        
    </section>
    
    <h2>Next</h2>
    
    <h2>Prev</h2>
        <div class="post card">
            <a href="/posts/hummingbird-routing-and-requests/" target="">
                <figure>
                    <picture>
                        <img
                            src=""
                            alt=""
                            title=""
                        >
                    </picture>
                </figure>
                <section>
                    <time datetime="2023-03-17 16:20:00">2023-03-17 16:20:00</time>
                    <h2 class="title">Hummingbird routing and requests</h2>
                </section>
                <p>Beginner&#39;s guide to learn all about routing and request handling using the Hummingbird server-side Swift framework.</p>
            </a>
        
            
            
        
        </div>
    
    <h2>Related</h2>
    Empty.
    
    <h2>More by author(s)</h2>
    Empty.

</article>

    </main>

    <footer id="page-footer">
        <section class="content-wrapper">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
    
            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p>
                <a href="https://binarybirds.com/">Home</a> ¬∑
                <a href="mailto:binarybirdsofficial@gmail.com">Email</a> ¬∑
                <a href="https://github.com/binarybirds/">GitHub</a> ¬∑
                <a href="https://x.com/tiborbodecs">Twitter</a> ¬∑
                <a href="/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="/sitemap.xml" target="_blank">Sitemap</a>
            </p>
    
            <p class="small"> &copy; 2022 - 2024.</p>
        </section>
    </footer>
</body>
</html>
