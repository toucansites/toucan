<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>The repository pattern for Vapor 4 - </title>
    <meta name="description" content="In this article I&#39;m going to talk about the repository design pattern and give you a few Fluent ORM tips for your Vapor 4 app.">
    
    <meta property="og:url" content="/posts/the-repository-pattern-for-vapor-4/">
    <meta property="og:title" content="The repository pattern for Vapor 4 - ">
    <meta property="og:description" content="In this article I&#39;m going to talk about the repository design pattern and give you a few Fluent ORM tips for your Vapor 4 app.">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="The repository pattern for Vapor 4 - ">
    <meta name="twitter:description" content="In this article I&#39;m going to talk about the repository design pattern and give you a few Fluent ORM tips for your Vapor 4 app.">
    
    <link rel="stylesheet" href="/css/global.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">

    <link rel="shortcut icon" href="/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-touch-icon-180x180.png">

</head>

<body>
    <header id="navigation">
        <a id="site-logo" href="">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
        </a>
    
        <nav id="primary-menu">
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/">Home</a>
                <a href="/blog/">Blog</a>
                <a href="/posts/pages/1/">Posts</a>
                <a href="/authors/">Authors</a>
                <a href="/tags/">Tags</a>
                <a href="/my-page/">My page</a>
            </div>
        </nav>
    
        <nav id="secondary-menu">
            <input type="checkbox" id="secondary-menu-button" name="menu-button" class="menu-button">
            <label for="secondary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="1"></circle>
                    <circle cx="12" cy="5" r="1"></circle>
                    <circle cx="12" cy="19" r="1"></circle>
                </svg>
            </label>
            <div class="menu-items right">
                <a href="#">My account</a>
                <a href="/">Logout</a>
            </div>
        </nav>
    </header>
        
    <main>

<article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2022-03-03 16:20:00">2022-03-03 16:20:00</time>
            <h1 class="title">The repository pattern for Vapor 4</h1>
            <p class="excerpt">In this article I&#39;m going to talk about the repository design pattern and give you a few Fluent ORM tips for your Vapor 4 app.</p>
        </section>
        
    </header>

    <section id="contents" class="content-wrapper">
    
    <h2>Fluent is essentially broken</h2><p>The more I use the <a href="https://docs.vapor.codes/4.0/fluent/overview/" target="_blank">Fluent ORM framework</a> the more I realize how hard it is to work with it. Im talking about a particular design issue that I also mentioned in <a href="https://theswiftdev.com/the-future-of-server-side-swift/" target="_blank">the future of server side Swift article</a>. I really dont like the idea of property wrappers and abstract database models.</p><p>Whats the problem with the current database model abstraction? First of all, the optional ID property is confusing. For example you dont have to provide an identifier when you insert a record, it can be an nil value and the ORM system can create a unique identifier (under the hood using a generator) for you. So why do we have an id for create operations at all? Yes, you might say that it is possible to specify a custom identifier, but honestly how many times do we need that? If you want to identify a record thats going to be something like a key, not an id field. </p><p>Also this optional property can cause some other issues, when using fluent you can require an id, which is a throwing operation, alternatively you can unwrap the optional property if youre sure that the identifier already exists, but this is not a safe approach at all.</p><p>My other issue is related to initializers, if you define a custom model you always have to provide an empty <code>init() {}</code> method for it, otherwise the compiler will complain, because models have to be classes. BUT WHY? IMHO the reason relates to this issue: you can query the database models using the model itself. So the model acts like a repository that you can use to query the fields, and it also represents the the record itself. Isnt this against the clean principles? </p><p>Okay, one last thing. Property wrappers, field keys and migrations. The core members at Vapor told us that this approach will provide a safe way to query my models and I can be sure that field keys wont be messed up, but Im actually struggling with versioning in this case. I had to introduce a v1, v2, vN structure both for the field keys and the migration, which actually feels a bit worse than using raw strings. It is over-complicated for sure, and it feels like the schema definition is mixed up with the actual query mechanism and the model layer as well.</p><p>Sorry folks, I really appreciate the effort that youve put into Fluent, but these issues are real and I know that you can fix them on the long term and make the developer experience a lot better.</p><h2>How to make Fluent a bit better?</h2><p>On the short term Im trying to fix these issues and fortunately there is a nice approach to separate the query mechanism from the model layer. It is called the <a href="https://docs.vapor.codes/4.0/upgrading/#repositories" target="_blank">repository pattern</a> and Id like to give a huge credit to <a href="https://x.com/0xTim" target="_blank">0xTim</a> again, because he made a cool answer on <a href="https://stackoverflow.com/questions/63333118/understanding-how-to-initialize-a-vapor-4-repository" target="_blank">StackOverlow</a> about this topic.</p><p>Anyway, the main idea is that you wrap the <code>Request</code> object into a custom repository, its usually a struct, then you only call database related queries inside this specific object. If we take a look at at the default project template (you can generate one by using the <a href="https://docs.vapor.codes/4.0/install/linux/#install-toolbox" target="_blank">vapor toolbox</a>), we can easily create a new repository for the Todo models.</p><pre><code class="language-swift">import Vapor
import Fluent

struct TodoRepository {
    var req: Request
    
    /// initialize the repository with a request object
    init(req: Request) {
        self.req = req
    }
    
    /// query the Todo models using the req.db property
    func query() -> QueryBuilder<Todo> {
        Todo.query(on: req.db)
    }
    
    /// query the models and filter by an identifier
    func query(_ id: Todo.IDValue) -> QueryBuilder<Todo> {
        query().filter(\.$id == id)
    }
    
    /// query the models and filter by multiple identifiers
    func query(_ ids: [Todo.IDValue]) -> QueryBuilder<Todo> {
        query().filter(\.$id ~~ ids)
    }

    /// list all the available Todo items
    func list() async throws -> [Todo] {
        try await query().all()
    }
    
    /// get one Todo item by an identifier if it exists
    func get(_ id: Todo.IDValue) async throws -> Todo? {
        try await get([id]).first
    }

    /// get the list of the Todo items by multiple identifiers
    func get(_ ids: [Todo.IDValue]) async throws -> [Todo] {
        try await query(ids).all()
    }

    /// create a Todo model and return the updated model (with an id)
    func create(_ model: Todo) async throws -> Todo {
        try await model.create(on: req.db)
        return model
    }
    
    /// update a Todo model
    func update(_ model: Todo) async throws -> Todo {
        try await model.update(on: req.db)
        return model
    }

    /// delete a Todo item based on the identifier
    func delete(_ id: Todo.IDValue) async throws {
        try await delete([id])
    }

    /// delete multiple Todo items based on id values
    func delete(_ ids: [Todo.IDValue]) async throws {
        try await query(ids).delete()
    }
}
</code></pre><p>Thats how we are can manipulate Todo models, from now on you dont have to use the static methods on the model itself, but you can use an instance of the repository to alter your database rows. The repository can be hooked up to the Request object by using a common pattern. The most simple way is to return a service every time you need it.</p><pre><code class="language-swift">import Vapor

extension Request {
    
    var todo: TodoRepository {
        .init(req: self)
    }
}
</code></pre><p>Of course this is a very basic solution and it pollutes the namespace under the Request object, I mean, if you have lots of repositories this can be a problem, but first let me show you how to refactor the controller by using this simple method. </p><pre><code class="language-swift">import Vapor

struct TodoController: RouteCollection {

    func boot(routes: RoutesBuilder) throws {
        let todos = routes.grouped("todos")
        todos.get(use: index)
        todos.post(use: create)
        todos.group(":todoID") { todo in
            todo.delete(use: delete)
        }
    }

    func index(req: Request) async throws -> [Todo] {
        try await req.todo.list()
    }

    func create(req: Request) async throws -> Todo {
        let todo = try req.content.decode(Todo.self)
        return try await req.todo.create(todo)
    }

    func delete(req: Request) async throws -> HTTPStatus {
        guard let id = req.parameters.get("todoID", as: Todo.IDValue.self) else {
            throw Abort(.notFound)
        }
        try await req.todo.delete(id)
        return .ok
    }
}
</code></pre><p>As you can see this way we were able to eliminate the Fluent dependency from the controller, and we can simply call the appropriate method using the repository instance. Still if you want to unit test the controller it is not possible to mock the repository, so we have to figure out something about that issue. First we need some new protocols.</p><pre><code class="language-swift">public protocol Repository {
    init(_ req: Request)
}

public protocol TodoRepository: Repository {
    func query() -> QueryBuilder<Todo>
    func query(_ id: Todo.IDValue) -> QueryBuilder<Todo>
    func query(_ ids: [Todo.IDValue]) -> QueryBuilder<Todo>
    func list() async throws -> [Todo]
    func get(_ ids: [Todo.IDValue]) async throws -> [Todo]
    func get(_ id: Todo.IDValue) async throws -> Todo?
    func create(_ model: Todo) async throws -> Todo
    func update(_ model: Todo) async throws -> Todo
    func delete(_ ids: [Todo.IDValue]) async throws
    func delete(_ id: Todo.IDValue) async throws
}
</code></pre><p>Next were going to define a shared repository registry using the <code>Application</code> extension. This registry will allow us to register repositories for given identifiers, well use the RepositoryId struct for this purpose. The <code>RepositoryRegistry</code> will be able to return a factory instance with a reference to the required request and registry service, this way were going to be able to create an actual Repository based on the identifier. Of course this whole ceremony can be avoided, but I wanted to come up with a generic solution to store repositories under the <code>req.repository</code> namespace. </p><pre><code class="language-swift">public struct RepositoryId: Hashable, Codable {

    public let string: String
    
    public init(_ string: String) {
        self.string = string
    }
}

public final class RepositoryRegistry {

    private let app: Application
    private var builders: [RepositoryId: ((Request) -> Repository)]

    fileprivate init(_ app: Application) {
        self.app = app
        self.builders = [:]
    }

    fileprivate func builder(_ req: Request) -> RepositoryFactory {
        .init(req, self)
    }
    
    fileprivate func make(_ id: RepositoryId, _ req: Request) -> Repository {
        guard let builder = builders[id] else {
            fatalError("Repository for id `\(id.string)` is not configured.")
        }
        return builder(req)
    }
    
    public func register(_ id: RepositoryId, _ builder: @escaping (Request) -> Repository) {
        builders[id] = builder
    }
}

public struct RepositoryFactory {
    private var registry: RepositoryRegistry
    private var req: Request
    
    fileprivate init(_ req: Request, _ registry: RepositoryRegistry) {
        self.req = req
        self.registry = registry
    }

    public func make(_ id: RepositoryId) -> Repository {
        registry.make(id, req)
    }
}

public extension Application {

    private struct Key: StorageKey {
        typealias Value = RepositoryRegistry
    }
    
    var repositories: RepositoryRegistry {
        if storage[Key.self] == nil {
            storage[Key.self] = .init(self)
        }
        return storage[Key.self]!
    }
}

public extension Request {
    
    var repositories: RepositoryFactory {
        application.repositories.builder(self)
    }
}
</code></pre><p>As a developer you just have to come up with a new unique identifier and extend the RepositoryFactory with your getter for your own repository type.</p><pre><code class="language-swift">public extension RepositoryId {
    static let todo = RepositoryId("todo")
}

public extension RepositoryFactory {

    var todo: TodoRepository {
        guard let result = make(.todo) as? TodoRepository else {
            fatalError("Todo repository is not configured")
        }
        return result
    }
}
</code></pre><p>We can now register the FluentTodoRepository object, we just have to rename the original TodoRepository struct and conform to the protocol instead.</p><pre><code class="language-swift">// repository file
public struct FluentTodoRepository: TodoRepository {
    var req: Request
    
    public init(_ req: Request) {
        self.req = req
    }
    
    func query() -> QueryBuilder<Todo> {
        Todo.query(on: req.db)
    }

    // ... same as before
}

// configure.swift
app.repositories.register(.todo) { req in
    FluentTodoRepository(req)
}
</code></pre><p>Were going to be able to get the repository through the <code>req.repositories.todo</code> property. You dont have to change anything else inside the controller file.</p><pre><code class="language-swift">import Vapor

struct TodoController: RouteCollection {

    func boot(routes: RoutesBuilder) throws {
        let todos = routes.grouped("todos")
        todos.get(use: index)
        todos.post(use: create)
        todos.group(":todoID") { todo in
            todo.delete(use: delete)
        }
    }

    func index(req: Request) async throws -> [Todo] {
        try await req.repositories.todo.list()
    }

    func create(req: Request) async throws -> Todo {
        let todo = try req.content.decode(Todo.self)
        return try await req.repositories.todo.create(todo)
    }

    func delete(req: Request) async throws -> HTTPStatus {
        guard let id = req.parameters.get("todoID", as: Todo.IDValue.self) else {
            throw Abort(.notFound)
        }
        try await req.repositories.todo.delete(id)
        return .ok
    }
}
</code></pre><p>The best part of this approach is that you can simply replace the <code>FluentTodoRepository</code> with a <code>MockTodoRepository</code> for testing purposes. I also like the fact that we dont pollute the req.* namespace, but every single repository has its own variable under the repositories key.</p><p>You can come up with a generic <code>DatabaseRepository</code> protocol with an associated database Model type, then you could implement some basic features as a protocol extension for the Fluent models. Im using this approach and Im quite happy with it so far, what do you think? Should the Vapor core team add better support for repositories? Let me know on Twitter. 猴</p>
        
    </section>
    
    <h2>Next</h2>
    
    <h2>Prev</h2>
        <div class="post card">
            <a href="/posts/hummingbird-routing-and-requests/" target="">
                <figure>
                    <picture>
                        <img
                            src=""
                            alt=""
                            title=""
                        >
                    </picture>
                </figure>
                <section>
                    <time datetime="2023-03-17 16:20:00">2023-03-17 16:20:00</time>
                    <h2 class="title">Hummingbird routing and requests</h2>
                </section>
                <p>Beginner&#39;s guide to learn all about routing and request handling using the Hummingbird server-side Swift framework.</p>
            </a>
        
            
            
        
        </div>
    
    <h2>Related</h2>
    Empty.
    
    <h2>More by author(s)</h2>
    Empty.

</article>

    </main>

    <footer id="page-footer">
        <section class="content-wrapper">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
    
            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p>
                <a href="https://binarybirds.com/">Home</a> 路
                <a href="mailto:binarybirdsofficial@gmail.com">Email</a> 路
                <a href="https://github.com/binarybirds/">GitHub</a> 路
                <a href="https://x.com/tiborbodecs">Twitter</a> 路
                <a href="/rss.xml" target="_blank">RSS</a> 路
                <a href="/sitemap.xml" target="_blank">Sitemap</a>
            </p>
    
            <p class="small"> &copy; 2022 - 2024.</p>
        </section>
    </footer>
</body>
</html>
