<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Ultimate UICollectionView guide with iOS examples written in Swift - </title>
    <meta name="description" content="Learn how to use UICollectionView, with highly reusable UIKit components and some MVVM pattern without the going nuts with index path calculations.">
    
    <meta property="og:url" content="/posts/ultimate-uicollectionview-guide-with-ios-examples-written-in-swift/">
    <meta property="og:title" content="Ultimate UICollectionView guide with iOS examples written in Swift - ">
    <meta property="og:description" content="Learn how to use UICollectionView, with highly reusable UIKit components and some MVVM pattern without the going nuts with index path calculations.">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Ultimate UICollectionView guide with iOS examples written in Swift - ">
    <meta name="twitter:description" content="Learn how to use UICollectionView, with highly reusable UIKit components and some MVVM pattern without the going nuts with index path calculations.">
    
    <link rel="stylesheet" href="/css/global.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">

    <link rel="shortcut icon" href="/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-touch-icon-180x180.png">

</head>

<body>
    <header id="navigation">
        <a id="site-logo" href="">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
        </a>
    
        <nav id="primary-menu">
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/">Home</a>
                <a href="/blog/">Blog</a>
                <a href="/posts/pages/1/">Posts</a>
                <a href="/authors/">Authors</a>
                <a href="/tags/">Tags</a>
                <a href="/my-page/">My page</a>
            </div>
        </nav>
    
        <nav id="secondary-menu">
            <input type="checkbox" id="secondary-menu-button" name="menu-button" class="menu-button">
            <label for="secondary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="1"></circle>
                    <circle cx="12" cy="5" r="1"></circle>
                    <circle cx="12" cy="19" r="1"></circle>
                </svg>
            </label>
            <div class="menu-items right">
                <a href="#">My account</a>
                <a href="/">Logout</a>
            </div>
        </nav>
    </header>
        
    <main>

<article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2018-04-17 16:20:00">2018-04-17 16:20:00</time>
            <h1 class="title">Ultimate UICollectionView guide with iOS examples written in Swift</h1>
            <p class="excerpt">Learn how to use UICollectionView, with highly reusable UIKit components and some MVVM pattern without the going nuts with index path calculations.</p>
        </section>
        
    </header>

    <section id="contents" class="content-wrapper">
    
    <h2>Anatomy of the UICollectionView class</h2><p>If you‚Äôre not familiar with <a href="https://developer.apple.com/documentation/uikit/uicollectionview" target="_blank">UICollectionView</a>, I‚Äôd suggest to get familiar with this class immediately. They‚Äôre the basic building blocks for many apps provided by Apple and other third party developers. It‚Äôs like UITableView on steroids. Here is a quick intro about how to work with them through IB and Swift code. üíª</p><p><img src="layout.png" alt="Layout"></p><p>You might have noticed that I have a love for metal music. In this tutorial we‚Äôre going to build an Apple Music catalog like look from ground zero using only the mighty <code>UICollectionView</code> class. Headers, horizontal and vertical scrolling, circular images, so basically almost everything that you‚Äôll ever need to build great user interfaces. ü§òüèª</p><h2>How to make a UICollectionView using Interface Builder (IB) in Xcode?</h2><blockquote><p>The short & honest answer: you shouldn‚Äôt use IB!</p></blockquote><p>If you still want to use IB, here is a real quick tutorial for absolutely beginners:</p><p><img src="section.png" alt="Section"></p><p>The main steps of creating your first UICollectionView based screen are these:</p><ul><li>Drag a UICollectionView object to your view controller</li><li>Set proper constraints on the collection view</li><li>Set dataSource & delegate of the collection view</li><li>Prototype your cell layout inside the controller</li><li>Add constraints to your views inside the cell</li><li>Set prototype cell class & reuse identifier</li><li>Do a little coding:</li></ul><pre><code class="language-swift">import UIKit

class MyCell: UICollectionViewCell {
    @IBOutlet weak var textLabel: UILabel!
}

class ViewController: UIViewController {

    @IBOutlet weak var collectionView: UICollectionView!

    override func viewDidLayoutSubviews() {
        super.viewDidLayoutSubviews()

        if let flowLayout = collectionView.collectionViewLayout as? UICollectionViewFlowLayout {
            flowLayout.itemSize = CGSize(
                width: collectionView.bounds.width,
                height: 120
            )
        }
    }
}

extension ViewController: UICollectionViewDataSource {

    func numberOfSections(
        in collectionView: UICollectionView
    ) -> Int {
        1
    }

    func collectionView(
        _ collectionView: UICollectionView, 
        numberOfItemsInSection section: Int
    ) -> Int {
        10
    }

    func collectionView(
        _ collectionView: UICollectionView, 
        cellForItemAt indexPath: IndexPath
    ) -> UICollectionViewCell {
        let cell = collectionView.dequeueReusableCell(
            withReuseIdentifier: "MyCell", 
            for: indexPath
        ) as! MyCell

        cell.textLabel.text = String(indexPath.row + 1)
        return cell
    }
}

extension ViewController: UICollectionViewDelegate {

    func collectionView(
        _ collectionView: UICollectionView, 
        didSelectItemAt indexPath: IndexPath
    ) {
        print(indexPath.item + 1)
    }
}
</code></pre><p>In a nutshell, the data source will provide all the required data about how to populate the collection view, and the delegate will handle user events, such as tapping on a cell. You should have a clear understanding about the <a href="https://developer.apple.com/documentation/uikit/uicollectionviewdatasource" target="_blank">data source</a> and <a href="https://developer.apple.com/documentation/uikit/uicollectionviewdelegate" target="_blank">delegate</a> methods, so feel free to play with them for a little while. ‚å®Ô∏è</p><h2>How to setup a UICollectionView based screen programmatically?</h2><p>As you might have noticed cells are the core components of a collection view. They are derived from reusable views, this means that if you have a list of 1000 elements, there won‚Äôt be a thousand cells created for every element, but only a few that fills the size of the screen and when you scroll down the list these items are going to be reused to display your elements. This is only because of memory considerations, so unlike UIScrollView the UICollectionView (and UITableView) class is a really smart and efficient one, but this is also the reason why you have to prepare (reset the contents of) the cell every time before you display your actual data. üòâ</p><p>Initialization is also handled by the system, but it‚Äôs worth to mention that if you are working with Interface Builder, you should do your customization inside the <code>awakeFromNib</code> method, but if you are using code, <code>init(frame:)</code> is your place.</p><pre><code class="language-swift">import UIKit

class MyCell: UICollectionViewCell {

    weak var textLabel: UILabel!

    override init(frame: CGRect) {
        super.init(frame: frame)

        let textLabel = UILabel(frame: .zero)
        textLabel.translatesAutoresizingMaskIntoConstraints = false
        contentView.addSubview(textLabel)
        NSLayoutConstraint.activate([
            textLabel.topAnchor.constraint(
                equalTo: contentView.topAnchor
            ),
            textLabel.bottomAnchor.constraint(
                equalTo: contentView.bottomAnchor
            ),
            textLabel.leadingAnchor.constraint(
                equalTo: contentView.leadingAnchor
            ),
            textLabel.trailingAnchor.constraint(
                equalTo: contentView.trailingAnchor
            ),
        ])
        self.textLabel = textLabel

        contentView.backgroundColor = .lightGray
        textLabel.textAlignment = .center
    }

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)

        fatalError("Interface Builder is not supported!")
    }

    override func awakeFromNib() {
        super.awakeFromNib()

        fatalError("Interface Builder is not supported!")
    }

    override func prepareForReuse() {
        super.prepareForReuse()

        textLabel.text = nil
    }
}
</code></pre><p>Next we have to implement the view controller which is responsible for managing the collection view, we‚Äôre not using IB so we have to create it manually by <a href="https://theswiftdev.com/2018/06/14/mastering-ios-auto-layout-anchors-programmatically-from-swift/" target="_blank">using Auto Layout anchors</a> - like for the <code>textLabel</code> in the cell - inside the <code>loadView</code> method. After the view hierarchy is ready to rock, we also set the data source and delegate plus register our cell class for further reuse. Note that this is done automatically by the system if you are using IB, but if you prefer code you have to do it by calling the proper registration method. You can register both nibs and classes.</p><pre><code class="language-swift">import UIKit

class ViewController: UIViewController {

    weak var collectionView: UICollectionView!

    override func loadView() {
        super.loadView()

        let collectionView = UICollectionView(
            frame: .zero, 
            collectionViewLayout: UICollectionViewFlowLayout()
        )
        collectionView.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(collectionView)
        NSLayoutConstraint.activate([
            collectionView.topAnchor.constraint(
                equalTo: view.topAnchor
            ),
            collectionView.bottomAnchor.constraint(
                equalTo: view.bottomAnchor
            ),
            collectionView.leadingAnchor.constraint(
                equalTo: view.leadingAnchor
            ),
            collectionView.trailingAnchor.constraint(
                equalTo: view.trailingAnchor
            ),
        ])
        self.collectionView = collectionView
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        collectionView.backgroundColor = .white
        collectionView.dataSource = self
        collectionView.delegate = self
        collectionView.register(
            MyCell.self,
            forCellWithReuseIdentifier: "MyCell"
        )
    }
}

extension ViewController: UICollectionViewDataSource {

    func numberOfSections(
        in collectionView: UICollectionView
    ) -> Int {
        1
    }

    func collectionView(
        _ collectionView: UICollectionView, 
        numberOfItemsInSection section: Int
    ) -> Int {
        10
    }

    func collectionView(
        _ collectionView: UICollectionView, 
        cellForItemAt indexPath: IndexPath
    ) -> UICollectionViewCell {
        let cell = collectionView.dequeueReusableCell(
            withReuseIdentifier: "MyCell", 
            for: indexPath
        ) as! MyCell

        cell.textLabel.text = String(indexPath.row + 1)
        return cell
    }
}

extension ViewController: UICollectionViewDelegate {

    func collectionView(
        _ collectionView: UICollectionView, 
        didSelectItemAt indexPath: IndexPath
    ) {
        print(indexPath.row + 1)
    }
}

extension ViewController: UICollectionViewDelegateFlowLayout {

    func collectionView(
        _ collectionView: UICollectionView,
        layout collectionViewLayout: UICollectionViewLayout,
        sizeForItemAt indexPath: IndexPath
    ) -> CGSize {
        .init(
            width: collectionView.bounds.size.width - 16, 
            height: 120
        )
    }
    func collectionView(
        _ collectionView: UICollectionView,
        layout collectionViewLayout: UICollectionViewLayout,
        minimumLineSpacingForSectionAt section: Int
    ) -> CGFloat {
        8
    }

    func collectionView(
        _ collectionView: UICollectionView,
        layout collectionViewLayout: UICollectionViewLayout,
        minimumInteritemSpacingForSectionAt section: Int
    ) -> CGFloat {
        0
    }

    func collectionView(
        _ collectionView: UICollectionView,
        layout collectionViewLayout: UICollectionViewLayout,
        insetForSectionAt section: Int
    ) -> UIEdgeInsets {
        .init(top: 8, left: 8, bottom: 8, right: 8)
    }
}
</code></pre><p>This time you should pay some attention on the flow layout delegate methods. You can use these methods to provide metrics for the layout system. The flow layout will display all the cells based on these numbers and sizes. sizeForItemAt is responsible for the cell size, <code>minimumInteritemSpacingForSectionAt</code> is the horizontal padding, <code>minimumLineSpacingForSectionAt</code> is the vertical padding, and <code>insetForSectionAt</code> is for the margin of the collection view section.</p><h2>Using supplementary elements (section headers and footers)</h2><p>So in this section I‚Äôm going to both use storyboards, nibs and some Swift code. This is my usual approach for a few reasons. Although I love making constraints from code, most people prefer visual editors, so all the cells are created inside nibs. Why nibs? Because if you have multiple collection views this is ‚Äúalmost‚Äù the only nice way to share cells between them.</p><p>You can create section footers exactly the same way as you do headers, so that‚Äôs why this time I‚Äôm only going to focus on headers, because literally you only have to change one word in order to use footers. ‚öΩÔ∏è</p><p><img src="cell.png" alt="Cell"></p><p>You just have to create two xib files, one for the cell and one for the header. Please note that you could use the exact same collection view cell to display content in the section header, but this is a demo so let‚Äôs just go with two distinct items. You don‚Äôt even have to set the reuse identifier from IB, because we have to register our reusable views inside the source code, so just set the cell class and connect your outlets.</p><p>Cell and supplementary element registration is slightly different for nibs.</p><pre><code class="language-swift">let cellNib = UINib(nibName: "Cell", bundle: nil)
self.collectionView.register(
    cellNib, 
    forCellWithReuseIdentifier: "Cell"
)

let sectionNib = UINib(nibName: "Section", bundle: nil)
self.collectionView.register(
    sectionNib, 
    forSupplementaryViewOfKind: UICollectionView.elementKindSectionHeader, 
    withReuseIdentifier: "Section"
)
</code></pre><p>Implementing the data source for the section header looks like this.</p><pre><code class="language-swift">func collectionView(
    _ collectionView: UICollectionView,
    viewForSupplementaryElementOfKind kind: String,
    at indexPath: IndexPath
) -> UICollectionReusableView {

    guard kind == UICollectionView.elementKindSectionHeader else {
        return UICollectionReusableView()
    }
    let view = collectionView.dequeueReusableSupplementaryView(
        ofKind: kind, 
        withReuseIdentifier: "Section", 
        for: indexPath
    ) as! Section

    view.textLabel.text = String(indexPath.section + 1)
    return view
}
</code></pre><p>Providing the size for the flow layout delegate is also pretty straightforward, however sometimes I don‚Äôt really get the naming conventions by Apple. Once you have to switch a kind, and the other time there are exact methods for specific kinds. ü§∑‚Äç‚ôÇÔ∏è</p><pre><code class="language-swift">func collectionView(
    _ collectionView: UICollectionView,
    layout collectionViewLayout: UICollectionViewLayout,
    referenceSizeForHeaderInSection section: Int
) -> CGSize {
    .init(
        width: collectionView.bounds.size.width, 
        height: 64
    )
}
</code></pre><p>Starting from iOS9 section headers and footers can be pinned to the top or bottom of the visible bounds of the collection view.</p><pre><code class="language-swift">if let flowLayout = self.collectionView.collectionViewLayout as? UICollectionViewFlowLayout {
    flowLayout.sectionHeadersPinToVisibleBounds = true
}
</code></pre><p>That‚Äôs it, now you know how to build basic layouts with collection view.</p><p>What about complex cases, like using multiple kinds of cells in the same collection view? Things can get pretty messy with index paths, so that‚Äôs why I re-invented something better based on a technique how to build <a href="https://developer.apple.com/videos/play/wwdc2014/232/" target="_blank">advanced user interfaces with collection views</a> showcased by Apple back at WWDC 2014.</p><h2>My CollectionView based UI framework</h2><p>Now you know the basics, so why don‚Äôt we get straight to the point? I‚Äôll show you my best practice of building great user interfaces by using my MVVM architecture based CollectionView micro framework.</p><blockquote><p>CollectionView + ViewModel pattern = ‚ù§Ô∏è .</p></blockquote><p>I‚Äôll explain the components real quick and after that you‚Äôll learn how to use them to build up the Apple music-ish layout that I was talking about in the beginning. üé∂</p><h3>Grid system</h3><p>The first problem with collection views is the size calculation. You have to provide the size (width & height) for each cell inside your collection view.</p><ul><li>if everything has a fixed size inside your collection view, you can just set the size properties on the flow layout itself</li><li>if you need dynamic sizes per item, you can implement the flow layout delegate aka. UICollectionViewDelegateFlowLayout (why is the delegate word in the middle of the name???) and return the exact sizes for the layout system</li><li>if you need even more control you can create a new layout subclass derived from CollectionView(Flow)Layout and do all the size calculations there</li></ul><p>Thats good, but still you have to mess with index paths, trait collections, frames and many more in order to have a simple 2, 4, n column layout that adapts on every device. This is the reason why I‚Äôve created a really basic grid system for size calculation. With my grid class you can just set the number of columns and get back the size for x amount of columns, ‚Äújust like‚Äù in web based css grid systems. üï∏</p><h3>Cell reuse</h3><p>Registering and reusing cells should and can be automated in a type safe manner. You just want to use the cell, and you shouldn‚Äôt care about reuse identifiers and cell registration at all. I‚Äôve made a couple helper methods in order to make the progress more pleasant. Reuse identifiers are derived from the name of the cell classes, so you dont‚Äôt have to worry about anymore. This is a practice that most of the developers use.</p><h3>View model</h3><blockquote><p>view model = cell (view) + data (model)</p></blockquote><p>Filling up ‚Äútemplate‚Äù cell with real data should be the task of a view model. This is where MVVM comes into play. I‚Äôve made a generic base view model class, that you should subclass. With the help of a protocol, you can use various cells in a single collection view without going crazy of the row & section calculations and you can focus on one simple task: connecting view with models. üòõ</p><h3>Section</h3><blockquote><p>section = header + footer + cells</p></blockquote><p>I‚Äôm trying to emphasize that you don‚Äôt want to mess with index paths, you just want to put your data together and that‚Äôs it. In the past I‚Äôve struggled more than enough with ‚Äúunnecessary index path math‚Äù, so I‚Äôve made the section object as a simple container to wrap headers, footers and all the items inside of the section. The result? Generic data source class that can be used with multiple cells without any row or section index calculations. üëèüëèüëè</p><h3>Source</h3><p>So in order to make all the things I‚Äôve mentioned above work, I needed to implement the collection view delegate, data source, and flow layout delegate methods. That‚Äôs how my source class was born. Everything is implemented here, and I‚Äôm using sections, view models the grid system to build up collection views. But hey, enough from this theory, let‚Äôs see it in practice. üëì</p><h2>CollectionView framework example application</h2><p>How to make a any list or grid layout hassle free? Well, as a first step just add my <a href="https://github.com/corekit/collectionview" target="_blank">CollectionView framework</a> as a dependency. Don‚Äôt worry you won‚Äôt regret it, plus it supports Xcode 11 already, so you can use the Swift Package Manager, straight from the file menu to integrate this package.</p><p>Tip: just add the <code>@_exported import CollectionView</code> line in the AppDelegate file, then you I don‚Äôt have to worry about importing the framework file-by-file.</p><h3>Step 1. Make the cell.</h3><p>This step is identical with the regular setup, except that your cell have to be a subclass of my Cell class. Add your own cell and do everything as you would do normally.</p><pre><code class="language-swift">import UIKit

class AlbumCell: Cell {

    @IBOutlet weak var textLabel: UILabel!
    @IBOutlet weak var detailTextLabel: UILabel!
    @IBOutlet weak var imageView: UIImageView!

    override func awakeFromNib() {
        super.awakeFromNib()

        self.textLabel.font = UIFont.systemFont(ofSize: 12, weight: .bold)
        self.textLabel.textColor = .black

        self.detailTextLabel.font = UIFont.systemFont(ofSize: 12, weight: .bold)
        self.detailTextLabel.textColor = .darkGray

        self.imageView.layer.cornerRadius = 8
        self.imageView.layer.masksToBounds = true
    }

    override func reset() {
        super.reset()

        self.textLabel.text = nil
        self.detailTextLabel.text = nil
        self.imageView.image = nil
    }
}
</code></pre><h3>Step 2. Make a model</h3><p>Just pick a model object. It can be anything, but my approach is to make a new struct or class with a Model suffix. This way I know that models are referencing the collection view models inside my reusable components folder.</p><pre><code class="language-swift">import Foundation

struct AlbumModel {
    let artist: String
    let name: String
    let image: String
}
</code></pre><h3>Step 3. Make the view model.</h3><p>Now instead of configuring the cell inside the delegate, or in a configure method somewhere, let‚Äôs make a real view model for the cell & the data model that‚Äôs going to be represented via the view.</p><pre><code class="language-swift">import UIKit

class AlbumViewModel: ViewModel<AlbumCell, AlbumModel> {

    override func updateView() {
        self.view?.textLabel.text = self.model.artist
        self.view?.detailTextLabel.text = self.model.name
        self.view?.imageView.image = UIImage(named: self.model.image)
    }

    override func size(grid: Grid) -> CGSize {
        if
            (self.collectionView.traitCollection.userInterfaceIdiom == .phone &&
             self.collectionView.traitCollection.verticalSizeClass == .compact) ||
            self.collectionView?.traitCollection.userInterfaceIdiom == .pad
        {
            return grid.size(
                for: self.collectionView, 
                ratio: 1.2, 
                items: grid.columns / 4, 
                gaps: grid.columns - 1
            )
        }
        if grid.columns == 1 {
            return grid.size(for: self.collectionView, ratio: 1.1)
        }
        return grid.size(
            for: self.collectionView, 
            ratio: 1.2, 
            items: grid.columns / 2,
            gaps: grid.columns - 1
        )
    }
}
</code></pre><h3>Step 4. Setup your data source.</h3><p>Now, use your real data and populate your collection view using the view models.</p><pre><code class="language-swift">let grid = Grid(columns: 1, margin: UIEdgeInsets(all: 8))
self.collectionView.source = .init(grid: grid, [
    [
        HeaderViewModel(.init(title: "Albums"))
        AlbumViewModel(self.album)
    ],
])
self.collectionView.reloadData()
</code></pre><h3>Step 5. üç∫ü§òüèªüé∏</h3><p>Congratulations you‚Äôre done with your first collection view. With just a few lines of code you have a ROCK SOLID code that will help you out in most of the situations! üòé</p><blockquote><p>This is just the tip of the iceberg! üö¢</p></blockquote><h2>Horizontal scrolling inside vertical scrolling</h2><p>What if we make a cell that contains a collection view and we use the same method like above? A collection view containing a collection view‚Ä¶ UICollectionViewception!!! üòÇ</p><p>It‚Äôs completely possible, and really easy to do, the data that feeds the view model will be a collection view source object, and you‚Äôre done. Effortless, magical and super nice to implement, also included in the example app.</p><h3>Sections with artists & circular images</h3><p>Multiple sections? No problem, circular images? That‚Äôs also a piece of cake, if you had read my previous <a href="https://theswiftdev.com/2018/01/24/uicollectionview-cells-with-circular-images-plus-rotation-support/" target="_blank">tutorial about circular collection view cells</a>, you‚Äôll know how to do it, but please check out the source code from GitLab and see it for yourself in action.</p><h3>Callbacks and actions</h3><p>User events can be handled very easy, because view models can have delegates or callback blocks, it only depends on you which one you prefer. The example contains an onSelect handler, which is super nice and built-in to the framework. üòé</p><h3>Dynamic cell sizing re-imagined</h3><p>I also had a <a href="https://theswiftdev.com/2018/01/23/self-sizing-cells-with-rotation-support/" target="_blank">tutorial about collection view self sizing cell support</a>, but to be honest I‚Äôm not a big fan of Apple‚Äôs official method. After I‚Äôve made the grid system and started using view models, it was more easy to calculate cell heights by myself, with about 2 lines of extra code. I believe that‚Äôs worth it, because self sizing cells are a little buggy if it comes to auto rotation.</p><h3>Rotation support, adaptivity</h3><p>Don‚Äôt worry about that too much, you can simply change the grid or check trait collections inside the view model if you want. I‚Äôd say almost everything can be done right out of the box. My collection view micro framework is just a lightweight wrapper around the official collection view APIs. That‚Äôs the beauty of it, feel free to do whatever you want and use it in a way that YOU personally prefer. üì¶</p><p>Now go, grab the <a href="https://github.com/theswiftdev/tutorials" target="_blank">sample code</a> and listen to some metal! ü§òüèª</p><h2>What if I told you‚Ä¶ one more thing: SwiftUI</h2><p>These are some original quotes of mine back from April, 2018:</p><blockquote><p>If you like this method that‚Äôs cool, but what if I told you that there is more? Do you want to use the same pattern everywhere? I mean on iOS, tvOS, macOS and even watchOS. Done deal! I‚Äôve created everything inside the CoreKit framework. UITableViews, WKInterfaceTables are supported as well.</p></blockquote><p>Well, I‚Äôm a visionary, but SwiftUI was late 1 year, it arrived in 2019:</p><blockquote><p>I really believe that Apple this year will approach the next generation UIKit / AppKit / UXKit frameworks (written in Swift of course) somewhat like this. I‚Äôm not talking about the view model pattern, but about the same API on every platform thinking. Anyway, who knows this for sue, we‚Äôll see‚Ä¶ #wwdc18 ü§î</p></blockquote><p>If someone from Apple reads this, please explain me why the hell is SwiftUI still an abstraction layer above UIKit/ AppKit instead of a refactored AppleKit UI framework that finally unifies every single API? For real, why? Still don‚Äôt get it. ü§∑‚Äç‚ôÇÔ∏è</p><p>Anyway, we‚Äôre going in to the same direction guys, year-by-year I delete more and more self-written ‚Äú3rd-party‚Äù code, so you‚Äôre doing great progress there! üçé</p>
        
    </section>
    
    <h2>Next</h2>
    
    <h2>Prev</h2>
        <div class="post card">
            <a href="/posts/hummingbird-routing-and-requests/" target="">
                <figure>
                    <picture>
                        <img
                            src=""
                            alt=""
                            title=""
                        >
                    </picture>
                </figure>
                <section>
                    <time datetime="2023-03-17 16:20:00">2023-03-17 16:20:00</time>
                    <h2 class="title">Hummingbird routing and requests</h2>
                </section>
                <p>Beginner&#39;s guide to learn all about routing and request handling using the Hummingbird server-side Swift framework.</p>
            </a>
        
            
            
        
        </div>
    
    <h2>Related</h2>
    Empty.
    
    <h2>More by author(s)</h2>
    Empty.

</article>

    </main>

    <footer id="page-footer">
        <section class="content-wrapper">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
    
            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p>
                <a href="https://binarybirds.com/">Home</a> ¬∑
                <a href="mailto:binarybirdsofficial@gmail.com">Email</a> ¬∑
                <a href="https://github.com/binarybirds/">GitHub</a> ¬∑
                <a href="https://x.com/tiborbodecs">Twitter</a> ¬∑
                <a href="/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="/sitemap.xml" target="_blank">Sitemap</a>
            </p>
    
            <p class="small"> &copy; 2022 - 2024.</p>
        </section>
    </footer>
</body>
</html>
